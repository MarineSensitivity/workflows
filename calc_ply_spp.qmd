---
title: "Tabulate Species"
format: html
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
librarian::shelf(
  DBI, dplyr, dbplyr, glue, here, httr2, jsonlite, lubridate,
  MarineSensitivity/msens,
  readr, sf, stringr, tictoc, tidyr)
source("libs/db.R")
```

```{r}
#| label: ply_species reset
#| eval: false

dbExecute(
  con,"CREATE TABLE IF NOT EXISTS 
    public.ply_species(
      ply_tbl text,
      ply_fld text,
      ply_key text,
      sp_key text,
      area_km2 double precision,
      avg_suit double precision)")

dbExecute(
  con, "DELETE FROM public.ply_species")

```


```{r}
#| label: ply_species for all blocks

# TODO: add req_timeout(60*20) to R fxn so timeout is 20 min, not 10 min
# https://httr2.r-lib.org/reference/req_timeout.html
# erEGOM-paEGM: 921.262 sec / 60 = 15.4 min

# get_species_by_feature_localdb <- function(
    #     schema.table = "raw.mr_eez",
#     where        = "mrgid = 8442"){

# schema.table = "public.ply_ecoblks"
# where        = "ecoarea_key = 'erCAC-paCEC'"

# source(here("../workflows/libs/db.R")) # define: con

# tbl(con, "ply_ecoblks") |> 
#   arrange(br_er_pa_pd_bk_key) |> 
#   head(1) |> 
#   pull(br_er_pa_pd_bk_key) # "AK_CBS_BFT_NR05-01_6002"
schema = "public"
table  = "ply_ecoblks"
fld    = "br_er_pa_pd_bk_key"

fld_geom <- dbGetQuery(
  con,
  glue("
      SELECT f_geometry_column
      FROM geometry_columns
      WHERE
        f_table_schema = '{schema}' AND
        f_table_name   = '{table}';")) |>
  pull(f_geometry_column)
# message(glue("schema.table: '{schema}.{table}'; fld_geom: '{fld_geom}'"))

keys <- tbl(con, table) |> 
  arrange(!!as.symbol(fld)) |>
  pull(!!as.symbol(fld))

n_keys <- format(length(keys), big.mark=',')  # 309,229
t0     <- Sys.time()                          # t0 = as_datetime("2025-01-24 22:38:30.486211")
for (i in 1:length(keys)){

  key   <- keys[i]
  where <- glue("{fld} = '{key}'")
  
  if (i %% 100 == 0){
    #     300: AK_CBS_BFT_NR05-01_6659     ~ 2025-01-24 22:38:30.486211
    # 309,200: PAC_WAOR_WAO_NM10-07_7111   ~ 2025-01-25 08:58:55.109335
    t1     <- Sys.time() # t1 = as_datetime("2025-01-24 23:05:37.41435")
    i_togo <- length(keys) - i
    eta <- t1 + ((t1 - t0) / i) * i_togo
    message(glue(
      "{str_pad(format(i, big.mark=','), nchar(n_keys))}: {key}  ~ {Sys.time()}
       ...ETA: {format(eta, tz='America/Los_Angeles')} PST"))
  }
  
  # if (i == 293)
  #   dbExecute(
  #     con, glue("DELETE FROM public.ply_species WHERE ply_key = '{key}'"))
  # tbl(con, "ply_species") |> 
  #   filter(ply_key == key)
  
  q <- glue("
    WITH
      c AS (
        SELECT
        c.cell_id,
        c.area_km2 AS cell_km2,
        CASE
          WHEN ST_CoveredBy(c.geom, a.{fld_geom})
            THEN c.geom
          ELSE
            ST_Multi(ST_Intersection(c.geom, a.{fld_geom}))
        END AS geom
      FROM
        aquamaps.cells c
        INNER JOIN {table} a
          ON ST_Intersects(c.geom, a.{fld_geom})
            AND NOT ST_Touches(c.geom, a.{fld_geom})
      WHERE
        a.{where}
      ORDER BY
        c.cell_id),
    k AS (
      SELECT *,
        ST_AREA(geom::geography) / (1000 * 1000) AS aoi_km2
      FROM c),
    a AS (
      SELECT *,
        aoi_km2 / cell_km2 AS pct_cell
      FROM k),
    s AS (
      SELECT a.*,
        sc.sp_key, sc.probability
      FROM a
        LEFT JOIN aquamaps.spp_cells sc
          ON a.cell_id = sc.cell_id),
    g AS (
      SELECT
        sp_key,
        COUNT(*)                                  AS n_cells,
        AVG(pct_cell)                             AS avg_pct_cell,
        SUM(aoi_km2)                              AS area_km2,
        SUM(probability * aoi_km2) / SUM(aoi_km2) AS avg_suit
      FROM s
      GROUP BY sp_key),
    r AS (
      SELECT
        sp_key, area_km2, avg_suit
      FROM
        g
        LEFT JOIN aquamaps.spp USING (sp_key))
    INSERT INTO public.ply_species(
      ply_tbl, ply_fld, ply_key, sp_key, area_km2, avg_suit)
    SELECT
      '{schema}.{table}' AS ply_tbl, 
      '{fld}' AS ply_fld, 
      '{key}' AS ply_key,
      sp_key, 
      area_km2, 
      avg_suit
    FROM r")
  # message(q)
  
  dbExecute(con, q)
}
```


```{r}
#| label: ecoblk_cell

# source(here("../workflows/libs/db.R")) # define: con

# tbl(con, "ply_ecoblks") |> 
#   group_by(prodiag_ukey) |> 
#   summarize(n = n()) |> 
#   arrange(desc(n)) |> 
#   collect()
# brAK_erEBS_paALA_pdNM01-08    1122
  
# dbExecute(con, "ALTER TABLE ply_ecoblks ADD PRIMARY KEY (blk_ukey)")
tbl(con, "cells")

# TODO: check 

dbExecute(con, "
  UPDATE public.ply_ecoblks
    SET area_km2 = ST_AREA(geom::geography) / (1000 * 1000)")

dbExecute(con, "DROP TABLE IF EXISTS public.ecoblk_cell")
dbExecute(con, "
  CREATE TABLE IF NOT EXISTS public.ecoblk_cell (
    blk_ukey TEXT, 
    cell_id INTEGER, 
    area_km2 double precision, 
    blk_pct double precision, 
    geom geometry(Geometry,4326) )")

q <- "
  WITH
    b AS (
      SELECT b.blk_ukey, 
      c.cell_id,
      b.area_km2 AS blk_km2,
      CASE
        WHEN ST_CoveredBy(b.geom, c.geom)
          THEN b.geom
        ELSE
          ST_Multi(ST_Buffer(ST_Intersection(b.geom, c.geom), 0.0))
      END AS geom
    FROM
      public.ply_ecoblks b
      INNER JOIN aquamaps.cells c
        ON ST_Intersects(b.geom, c.geom)
    -- DEBUG: test subset
    -- WHERE
    --    b.prodiag_ukey = 'brAK_erEBS_paALA_pdNM01-08'
    ORDER BY
      b.blk_ukey, c.cell_id),
  a AS (
    SELECT *,
      ST_AREA(geom::geography) / (1000 * 1000) AS area_km2
    FROM b
    WHERE
      NOT ST_IsEmpty(geom))
  INSERT INTO public.ecoblk_cell(
    blk_ukey, cell_id, area_km2, blk_pct, geom)
  SELECT blk_ukey, cell_id,
    area_km2,
    area_km2 / blk_km2 AS blk_pct,
    geom
  FROM a"
dbExecute(con, q) # 377,321

dbExecute(
  con, "CREATE INDEX IF NOT EXISTS ecoblk_cell_geom_idx 
    ON ecoblk_cell USING gist (geom)")
dbExecute(
  con, "ALTER TABLE IF EXISTS ecoblk_cell
    ADD CONSTRAINT ecoblk_cell_pkey PRIMARY KEY (blk_ukey, cell_id)")
dbExecute(
  con, "CREATE INDEX IF NOT EXISTS idx_ecoblk_cell_cell_id ON ecoblk_cell (cell_id)")

# bc <- st_read(
#   con, query = "SELECT * FROM ecoblk_cell WHERE prodiag_ukey = 'brAK_erEBS_paALA_pdNM01-08'")
# sf::st_geometry_type(bc) |> table()
# mapView(bc, zcol = "pct_blk")
```

```{r}
#| label: ecoprot_cell

# source(here("../workflows/libs/db.R")) # define: con

# tbl(con, "ply_ecoprot") |>
#   group_by(planarea_ukey) |>
#   summarize(n = n()) |>
#   arrange(desc(n)) |>
#   collect()
# brAK_erEBS_paALA  52
#
# tbl(con, "cells")

dbExecute(con, "DROP TABLE IF EXISTS public.ecoprot_cell")
dbExecute(con, "
  CREATE TABLE IF NOT EXISTS public.ecoprot_cell (
    prodiag_ukey TEXT, 
    cell_id INTEGER, 
    area_km2 double precision, 
    prot_pct double precision, 
    geom geometry(Geometry,4326) )")

q <- "
  WITH
    p AS (
      SELECT p.prodiag_ukey, 
      c.cell_id,
      p.area_km2 AS prot_km2,
      CASE
        WHEN ST_CoveredBy(p.geom, c.geom)
          THEN p.geom
        ELSE
          ST_Multi(ST_Buffer(ST_Intersection(p.geom, c.geom), 0.0))
      END AS geom
    FROM
      public.ply_ecoprot p
      INNER JOIN aquamaps.cells c
        ON ST_Intersects(p.geom, c.geom)
    -- DEBUG: test subset
    -- WHERE
    --   p.planarea_ukey = 'brAK_erEBS_paALA'
    ORDER BY
      p.prodiag_ukey, c.cell_id),
  a AS (
    SELECT *,
      ST_AREA(geom::geography) / (1000 * 1000) AS area_km2
    FROM p
    WHERE
      NOT ST_IsEmpty(geom))
  INSERT INTO public.ecoprot_cell(
    prodiag_ukey, cell_id, area_km2, prot_pct, geom)
  SELECT prodiag_ukey, cell_id,
    area_km2,
    area_km2 / prot_km2 AS prot_pct,
    geom
  FROM a"
dbExecute(con, q) # 7148

dbExecute(
  con, "CREATE INDEX IF NOT EXISTS ecoprot_cell_geom_idx 
    ON ecoprot_cell USING gist (geom)")
dbExecute(
  con, "ALTER TABLE IF EXISTS ecoprot_cell
    ADD CONSTRAINT ecoprot_cell_pkey PRIMARY KEY (prodiag_ukey, cell_id)")
dbExecute(
  con, "CREATE INDEX IF NOT EXISTS idx_ecoprot_cell_cell_id ON ecoprot_cell (cell_id)")

# ck <- st_read(
#   con, query = "SELECT * FROM ecoprot_cell WHERE prodiag_ukey LIKE 'brAK_erEBS_paALA%'")
# sf::st_geometry_type(ck) |> table()
# mapView(ck, zcol = "prot_pct")

```

```{r}
#| label: NEWEST ply_spp with ecoprot_cell

dbExecute(con, "DROP TABLE IF EXISTS public.ply_spp")
dbExecute(con, "CREATE TABLE IF NOT EXISTS public.ply_spp (
    ply_fld text,
    ply_key text,
    sp_key text,
    sp_km2 double precision,
    sp_suit double precision)")

# ply_spp by prot ----
# DEBUG: subset
# d <- tbl(con, "ply_ecoblks") |> 
#   filter(prodiag_ukey == "brAK_erEBS_paALA_pdNM01-08") |>  # DEBUG
#   select(blk_ukey) |>
#   left_join(
#       tbl(con, "ecoblk_cell") |> 
#       select(blk_ukey, cell_id, area_km2),
#     by = "blk_ukey") |> 
q_sel <- tbl(con, "ecoprot_cell") |> 
  select(prodiag_ukey, cell_id, area_km2) |> 
  left_join(
    tbl(con, "spp_cells") |> 
      # head(1) |> collect() |> names() |> paste(collapse = ", "),
      # sp_key, probability, fao_area_yn, bound_box_yn, cell_id
      select(cell_id, sp_key, probability),
    by = "cell_id") |> 
  group_by(prodiag_ukey, sp_key) |> 
  summarize(
    sp_km2  = sum(area_km2),
    sp_suit = sum(probability * area_km2) / sum(area_km2),
    .groups = "drop") |> 
  mutate(
    ply_fld = "prodiag_ukey",
    ply_key = prodiag_ukey) |> 
  select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
  # collect()
  sql_render()
  
tic("ply_spp: prot")
q <- glue("
  INSERT INTO ply_spp (ply_fld, ply_key, sp_key, sp_km2, sp_suit)
  {q_sel}") # 384,432: brAK_erEBS_paALA_pdNM01-08
# message(q)
dbExecute(con, q)
toc() # 71.33 sec

# ply_spp by planarea ----
q_sel <- tbl(con, "ecoprot_cell") |> 
  select(prodiag_ukey, cell_id, area_km2) |> 
  left_join(
    tbl(con, "ply_ecoprot") |>
      select(prodiag_ukey, planarea_ukey),
    by = "prodiag_ukey") |> 
  left_join(
    tbl(con, "spp_cells") |> 
      select(cell_id, sp_key, probability),
    by = "cell_id") |> 
  group_by(planarea_ukey, sp_key) |> 
  summarize(
    sp_km2  = sum(area_km2),
    sp_suit = sum(probability * area_km2) / sum(area_km2),
    .groups = "drop") |> 
  mutate(
    ply_fld = "planarea_ukey",
    ply_key = planarea_ukey) |> 
  select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
  sql_render()

tic("ply_spp: planarea")
q <- glue("
  INSERT INTO ply_spp (ply_fld, ply_key, sp_key, sp_km2, sp_suit)
  {q_sel}")
dbExecute(con, q) # 99,834
toc() # 61.051 sec

# ply_spp by ecorgn ----
q_sel <- tbl(con, "ecoprot_cell") |> 
  select(prodiag_ukey, cell_id, area_km2) |> 
  left_join(
    tbl(con, "ply_ecoprot") |>
      select(prodiag_ukey, ecorgn_ukey),
    by = "prodiag_ukey") |> 
  left_join(
    tbl(con, "spp_cells") |> 
      select(cell_id, sp_key, probability),
    by = "cell_id") |> 
  group_by(ecorgn_ukey, sp_key) |> 
  summarize(
    sp_km2  = sum(area_km2),
    sp_suit = sum(probability * area_km2) / sum(area_km2),
    .groups = "drop") |> 
  mutate(
    ply_fld = "ecorgn_ukey",
    ply_key = ecorgn_ukey) |> 
  select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
  sql_render()
  
tic("ply_spp: ecorgn")
q <- glue("
  INSERT INTO ply_spp (ply_fld, ply_key, sp_key, sp_km2, sp_suit)
  {q_sel}")
dbExecute(con, q) # 42,763
toc() # 41.193 sec
```

- [ ] TODO: iucnRedListCategory, group_gmbi, group_simple1

```{r}
#| label: d_ply_species_sum

d_ply_species_sum <- tbl(con, "ply_species") |> 
  group_by(ply_tbl, ply_fld) |> 
  summarize(
    n = n(), 
    .groups = "drop") |> 
  arrange(n) |> 
  collect()

View(d_ply_species_sum)
```


## Make `*_ukey` for er, pa, pd, bk

```{r}
#| label: make_ukeys

flds <- list(
  ecorgn   = "'br', boemrgn_key, '_er', ecorgn_key",
  planarea = "'br', boemrgn_key, '_er', ecorgn_key, '_pa', planarea_key",
  prodiag  = "'br', boemrgn_key, '_er', ecorgn_key, '_pa', planarea_key, '_pd', prodiag_key",
  blk      = "'br', boemrgn_key, '_er', ecorgn_key, '_pa', planarea_key, '_pd', prodiag_key, '_bk', blk_key")

for (fld in names(flds)){
  dbExecute(
    con,
    glue("ALTER TABLE public.ply_ecoblks ADD COLUMN IF NOT EXISTS {fld}_ukey TEXT"))
  
  dbExecute(
    con,
    glue("UPDATE public.ply_ecoblks SET {fld}_ukey = CONCAT({flds[[fld]]})"))
}
```

## Update `ply_species` with `blk_ukey`

```{r}
#| label: update_blk_ukey

# tbl(con, "ply_species") |> 
#   group_by(ply_fld) |> 
#   summarize(
#     n = n())
#   ply_fld                    n
#   <chr>                <int64>
# 1 br_er_pa_pd_bk_key 279226334

dbExecute(
  con,
  glue("ALTER TABLE public.ply_species RENAME COLUMN ply_key TO ply_key_old"))

dbExecute(
  con,
  glue("ALTER TABLE public.ply_species ADD COLUMN IF NOT EXISTS ply_key TEXT"))

dbExecute(
  con,
  "UPDATE public.ply_species ps
  SET
    ply_fld = 'blk_ukey',
    ply_key = pb.blk_ukey
  FROM public.ply_ecoblks pb
  WHERE ps.ply_key_old = pb.br_er_pa_pd_bk_key")
# 279,226,334

dbExecute(
  con, "ALTER TABLE public.ply_species DROP COLUMN IF EXISTS ply_key_old")

# TODO: drop ply_ecoblks.br_er_pa_pd_bk_key
dbExecute(
  con, "ALTER TABLE public.ply_ecoblks DROP COLUMN IF EXISTS br_er_pa_pd_bk_key")

```

## Add indexes to `ply_ecoblks`, `ply_species`

```{r}
#| label: add_indexes

dbExecute(
  con, "ALTER TABLE public.ply_species ADD PRIMARY KEY (ply_tbl, ply_fld, ply_key, sp_key)") # 42 min
dbExecute(
  con, "CREATE INDEX IF NOT EXISTS idx_ply_species_ply_key ON public.ply_species (ply_key)")
dbExecute(
  con, "CREATE INDEX IF NOT EXISTS idx_ply_species_sp_key ON public.ply_species (sp_key)")

# dbExecute(
#   con, "CREATE INDEX IF NOT EXISTS idx_ply_species_ply_key ON public.ply_species (ply_tbl)")
# TODO: add index on ply_species.sp_key to map distribution of species by block, prodiag, etc

add_idx <- function(tbl, flds, schema = "public", msg_only = F, pkey = F){
  if (pkey){
    q <- glue("ALTER TABLE {schema}.{tbl} ADD PRIMARY KEY (first_name, last_name)")    
  } else {
    idx_name <- "idx_{tbl}"
    q <- glue("CREATE INDEX IF NOT EXISTS idx_ply_ecoblks ON {tbl} (ply_tbl, ply_key)")
  }
  
  if (msg_only){
    message(q)
    return()
  }
  
  stop("doh")
  dbExecute(con, q)
}

# add index for compound key to table public.ply_species: ply_tbl, ply_fld, ply_key
mk_idx("ply_species", c("ply_tbl", "ply_fld", "ply_key"), pkey = T)

idxs <- list(
  "ply_species" = list(
    "ply_tbl",
    "ply_fld",
    "ply_key")
  "ply_ecoblks" = list(
    "boemrgn_key",
    "ecorgn_ukey",
    "planarea_ukey",
    "prodiag_ukey",
    "blk_ukey"))

for (tbl in names(idxs)){
  message(glue("tbl: {tbl}"))
  for (flds in idxs[[tbl]]){
    message(glue("flds: {paste(flds, collapse=',')}"))
    mk_idx(tbl, flds,msg_only = T)
  }
}
```


## Dissolve ply `ecoblks` to `boemrgns` > `ecorgns` > `planareas` > `prodiags`

- see ingest_blocks.qmd

## Fetch and Store Species Data

```{r}
insert_ply_species <- function(
    schema       = "public",
    tbl          = "ply_ecoareas",
    fld_key      = "ecoarea_key",
    tbl_ply_spp  = "ply_species",
    redo = F){
  
  # keys, all
  keys <- dbGetQuery(con, glue("SELECT {fld_key} FROM {schema}.{tbl} ORDER BY {fld_key}")) |> 
    pull(fld_key)
  
  # keys, done
  if (dbExistsTable(con, tbl_ply_spp) & !redo) {
    keys_done <- dbGetQuery(con, glue("SELECT DISTINCT ply_key FROM {tbl_ply_spp} WHERE ply_tbl = '{schema}.{tbl}' ORDER BY ply_key")) |> 
      pull(ply_key)
    
    keys <- setdiff(keys, keys_done)
  }
  
  if (length(keys) == 0){
    message(glue("All keys in {tbl}.{fld_key} were already processed and inserted into {tbl_ply_spp} ~ {Sys.time()}"))
    return(NULL)
  }
  
  # Iterate over each region key
  for (i in 1:length(keys)) {  # key = rgn_keys[1] # bad: i = 1; key = "ALA" # good: key = "WGM"
    key = keys[i]
    
    # message with time stamp
    tic()
    message(glue("{sprintf('%02d',i)}/{length(keys)}: {key} ~ {Sys.time()}"))
    
    # Fetch species data from API; wrap in tryCatch to avoid breaking the loop
    d_spp <- tryCatch({
      # msens::get_species_by_feature(
      get_species_by_feature_localdb(
        glue("public.{tbl}"),
        glue("{fld_key} = '{key}'")) }, 
      error = function(e) {
        message(glue(
          "
        Error fetching species data: {e$message}
        ~ {Sys.time()}"))
        source("libs/db.R") # reset database con
        return(NULL)
      })
    
    if (is.null(d_spp))
      next
    
    # add columns identifying polygon for species
    d_spp <- d_spp |>
      mutate(
        ply_tbl = glue("{schema}.{tbl}"),
        ply_fld = fld_key,
        ply_key = key) |>
      relocate(ply_tbl, ply_fld, ply_key)
    
    # clear existing if table exists
    if (dbExistsTable(con, tbl_ply_spp)) {
      dbExecute(con, glue("DELETE FROM {tbl_ply_spp} WHERE ply_tbl = '{schema}.{tbl}' AND ply_fld = '{fld_key}' AND ply_key = '{key}'"))
    }
      
    # append to database
    dbWriteTable(con, tbl_ply_spp, d_spp, append = TRUE, row.names = FALSE)

    toc <- toc(quiet = T)
    message(glue("{sprintf('%02d',i)}/{length(keys)}: {key} ~ {toc$callback_msg}"))
  }
}

# dbRemoveTable(con, "ply_species")

insert_ply_species(
  schema       = "public",
  tbl          = "ply_ecoareas",
  fld_key      = "ecoarea_key",
  tbl_ply_spp  = "ply_species",
  redo         = F)

# 01/17: erEGOM-paEGM ~ 2024-12-21 15:43:57.250182
# Error fetching species data: Failed to perform HTTP request.
# ~ 2024-12-21 15:53:58.042009
# 06/17: erGOA-paGOA ~ 2024-12-21 16:03:20.086948
# Error fetching species data: Failed to perform HTTP request.
# ~ 2024-12-21 16:13:20.706389
# 10/17: erNECS-paNOA ~ 2024-12-21 16:26:41.31597
# Error fetching species data: Failed to perform HTTP request.
# ~ 2024-12-21 16:36:41.934764
# 11/17: erSECS-paFLS ~ 2024-12-21 16:36:42.155532
# Error fetching species data: Failed to perform HTTP request.
# ~ 2024-12-21 16:46:42.77022

insert_ply_species(
  schema       = "public",
  tbl          = "ply_ecorgns",
  fld_key      = "ecorgn_key",
  tbl_ply_spp  = "ply_species",
  redo = F)
```



## OLD db: Fetch and Store Species Data

```{r}
# show region keys
dbGetQuery(con, glue("SELECT rgn_key FROM public.ply_rgns ORDER BY rgn_key")) |> 
  pull(rgn_key)
```

region keys (n = 27):
```
 [1] "ALA" "ALB" "BFT" "BOW" "CEC" "CGM" "CHU" "COK" "EGM"
[10] "FLS" "GEO" "GOA" "HI"  "HOP" "KOD" "MAT" "MDA" "NAL"
[19] "NAV" "NOA" "NOC" "NOR" "SHU" "SOA" "SOC" "WAO" "WGM"
```

```{r}
#| eval: false
insert_ply_species(
  schema       = "public",
  tbl          = "ply_shlfs",
  fld_key      = "shlf_key",
  tbl_ply_spp  = "ply_species",
  redo         = F)
```

```{r}
#| eval: false
insert_ply_species(
  schema       = "public",
  tbl          = "ply_rgns",
  fld_key      = "rgn_key",
  tbl_ply_spp  = "ply_species",
  redo = F)
```


Executing above:
```
01: ALA ~ 2024-12-11 23:32:20.493056
Error fetching species data for ALA: HTTP 500 Internal Server Error.
01: ALA ~ 1.41 sec elapsed
02: ALB ~ 2024-12-11 23:32:21.903263
Error fetching species data for ALB: HTTP 500 Internal Server Error.
02: ALB ~ 1.509 sec elapsed
03: BFT ~ 2024-12-11 23:32:23.413059
03: BFT ~ 35.018 sec elapsed
04: BOW ~ 2024-12-11 23:32:58.431392
Error fetching species data for BOW: HTTP 500 Internal Server Error.
04: BOW ~ 1.391 sec elapsed
05: CEC ~ 2024-12-11 23:32:59.822888
05: CEC ~ 93.324 sec elapsed
06: CGM ~ 2024-12-11 23:34:33.14729
06: CGM ~ 343.167 sec elapsed
07: CHU ~ 2024-12-11 23:40:16.315158
07: CHU ~ 20.115 sec elapsed
08: COK ~ 2024-12-11 23:40:36.431037
08: COK ~ 156.458 sec elapsed                                         
09: EGM ~ 2024-12-11 23:43:12.889954
Error fetching species data for EGM: HTTP 500 Internal Server Error.
09: EGM ~ 27.012 sec elapsed
10: FLS ~ 2024-12-11 23:43:39.902751
10: FLS ~ 607.625 sec elapsed                                 
11: GEO ~ 2024-12-11 23:53:47.529269
11: GEO ~ 199.316 sec elapsed                                 
12: GOA ~ 2024-12-11 23:57:06.845524
Error fetching species data for GOA: Failed to perform HTTP request.
12: GOA ~ 328.706 sec elapsed
13: HI ~ 2024-12-12 00:02:35.552604
Error fetching species data for HI: Failed to perform HTTP request.
...
06: HI ~ 1.417 sec elapsed
07: HOP ~ 2024-12-12 00:46:31.430755
07: HOP ~ 31.362 sec elapsed          
08: KOD ~ 2024-12-12 00:47:02.792726
08: KOD ~ 144.358 sec elapsed         
09: MAT ~ 2024-12-12 00:49:27.151273
09: MAT ~ 30.936 sec elapsed          
10: MDA ~ 2024-12-12 00:49:58.088405
10: MDA ~ 480.974 sec elapsed         
11: NAL ~ 2024-12-12 00:57:59.063676
11: NAL ~ 172.836 sec elapsed         
12: NAV ~ 2024-12-12 01:00:51.900245
12: NAV ~ 3.234 sec elapsed           
13: NOA ~ 2024-12-12 01:00:55.13549
13: NOA ~ 667.073 sec elapsed         
14: NOC ~ 2024-12-12 01:12:02.20922
14: NOC ~ 102.602 sec elapsed         
15: NOR ~ 2024-12-12 01:13:44.812222
15: NOR ~ 93.109 sec elapsed          
16: SHU ~ 2024-12-12 01:15:17.922195
16: SHU ~ 94.259 sec elapsed          
17: SOA ~ 2024-12-12 01:16:52.182344
17: SOA ~ 664.422 sec elapsed         
18: SOC ~ 2024-12-12 01:27:56.605175
18: SOC ~ 467.248 sec elapsed         
19: WAO ~ 2024-12-12 01:35:43.853924
19: WAO ~ 154.774 sec elapsed         
20: WGM ~ 2024-12-12 01:38:18.627972
20: WGM ~ 182.608 sec elapsed
```

Error fetching species data for:
```
ALA
ALB
BOW
EGM
GOA
HI
```

## Assign Taxa Groups

```{r taxa groups}
ply_spp <- tbl(con, "ply_species") |> 
  distinct(sp_key) |> 
  pull(sp_key)
  
length(ply_spp) # 10575
am_spp <- tbl(con, "spp") |> 
  pull(sp_key_am)

# setdiff(ply_spp, am_spp)
# setdiff(am_spp, ply_spp) # "Fis-27769"

dbExecute(
  con, "CREATE INDEX IF NOT EXISTS idx_spp_sp_key_am ON public.spp (sp_key_am)")

dbExecute(
  con, "ALTER TABLE public.spp ADD COLUMN IF NOT EXISTS group_gmbi text")

dbExecute(con, "
  UPDATE public.spp
  SET group_gmbi = CASE
      WHEN class = 'actinopterygii' AND family NOT IN ('Scombridae', 'Istiophoridae', 'Xiphiidae') 
        THEN 'Coastal fishes'
      WHEN class = 'cephalopoda' AND \"order\" NOT IN ('Myopsida','Oegopsida') 
        THEN 'Non-squid cephalopods'
      WHEN family IN ('Odobenidae', 'Otariidae', 'Phocidae') 
        THEN 'Pinnipeds'
      WHEN class = 'anthozoa' THEN 'Corals'
      WHEN \"order\" = 'Alismatales' THEN 'Seagrasses'
      WHEN genus = 'Avicennia' AND species = 'germinans' THEN 'Mangroves'
      WHEN family IN ('Scombridae', 'Istiophoridae', 'Xiphiidae') 
        THEN 'Tunas & billfishes'
      WHEN \"order\" IN ('Myopsida','Oegopsida') THEN 'Squids'
      WHEN \"order\" = 'Artiodactyla' THEN 'Cetaceans'
      WHEN \"order\" = 'Euphausiacea' THEN 'Euphausiids'
      WHEN class IN ('Malacostraca','Ostracoda','Branchiopoda','Cephalocarida','Maxillopoda') 
        THEN 'Crustaceans'
      WHEN class = 'Pycnogonida' THEN 'Sea spiders'
      WHEN class = 'Gastropoda' THEN 'Gastropods'
      WHEN class = 'Bivalvia' THEN 'Bivalves'
      WHEN class = 'Polyplacophora' THEN 'Chitons'
      WHEN class IN ('Ascidiacea','Thaliacea') THEN 'Tunicates'
      WHEN class = 'Elasmobranchii' THEN 'Sharks'
      WHEN class = 'Reptilia' THEN 'Reptiles'
      WHEN phylum = 'Echinodermata' THEN 'Echinoderms'
      WHEN phylum = 'Porifera' THEN 'Sponges'
      WHEN phylum = 'Annelida' THEN 'Worms'
      WHEN class = 'Hydrozoa' THEN 'Hydrozoans'
      ELSE 'Other'
    END") # 10,576

tbl(con, "spp") |> 
  pull(group_gmbi) |> 
  table(useNA = "ifany")
#   Bivalves  Chitons         Crustaceans  Echinoderms  Euphausiids  Gastropods 
#        717       64               1757           490           32        1428 
# Hydrozoans    Other           Pinnipeds  Sea spiders   Seagrasses      Sharks 
#        322     4359                  14          100            5         214 
#    Sponges   Squids  Tunas & billfishes    Tunicates        Worms 
#        247       88                  33          170          536 

dbExecute(con, glue("ALTER TABLE public.spp ADD COLUMN IF NOT EXISTS group_simple1 TEXT"))

dbExecute(con, glue("
  UPDATE public.spp
  SET group_simple1 = CASE
    WHEN class = 'Mammalia' 
      AND \"order\" IN ('Cetacea', 'Carnivora')
      AND family IN ('Balaenopteridae', 'Delphinidae', 'Phocidae', 'Otariidae')
      THEN 'Mammals'
    WHEN (phylum = 'Annelida' AND class = 'Polychaeta')
      OR (phylum = 'Mollusca' AND class IN ('Bivalvia', 'Gastropoda'))
      OR (phylum = 'Echinodermata')
      OR (phylum = 'Arthropoda' AND class = 'Malacostraca')
      THEN 'Benthic'
    WHEN phylum = 'Cnidaria'
      AND class IN ('Anthozoa', 'Hydrozoa')
      AND \"order\" IN ('Scleractinia', 'Alcyonacea')
      THEN 'Corals'
    WHEN phylum = 'Chordata'
      AND class = 'Actinopterygii'
      AND \"order\" IN ('Clupeiformes', 'Perciformes', 'Gadiformes')
      AND family IN ('Scombridae', 'Clupeidae', 'Gadidae')
      THEN 'Pelagic Fish'
    WHEN class = 'Aves'
      AND \"order\" IN ('Charadriiformes', 'Procellariiformes', 'Pelecaniformes')
      AND family IN ('Laridae', 'Procellariidae', 'Sulidae', 'Phalacrocoracidae')
      THEN 'Seabirds'
    WHEN class = 'Reptilia'
      AND \"order\" = 'Testudines'
      AND family IN ('Cheloniidae', 'Dermochelyidae')
      THEN 'Turtles'
    WHEN class = 'Elasmobranchii'
      THEN 'Elasmobranchs'
    WHEN (class = 'Actinopterygii' AND \"order\" NOT IN ('Clupeiformes', 'Perciformes', 'Gadiformes'))
      THEN 'Other Fish'
    WHEN (class NOT IN ('Mammalia', 'Aves', 'Reptilia', 'Elasmobranchii') 
      AND phylum != 'Cnidaria')
      THEN 'Other Invertebrates'
    ELSE 'Other'
  END"))

tbl(con, "spp") |> 
  pull(group_simple1) |> 
  table(useNA = "ifany")
#             Benthic  Corals  Elasmobranchs  Mammals  Other 
#                4897     191            214       42   3643 
# Other Invertebrates 
#                1589

# add column taxa if not already present
if (!("taxa" %in% dbListFields(con, tbl_ply_spp))) {
  dbExecute(con, glue("ALTER TABLE {tbl_ply_spp} ADD COLUMN taxa TEXT"))
}


where_taxa <- list(
  mammals = "class = 'Mammalia' 
    AND \"order\" IN ('Cetacea', 'Carnivora')
    AND family IN ('Balaenopteridae', 'Delphinidae', 'Phocidae', 'Otariidae')",
  
  benthos = "(phylum = 'Annelida' AND class = 'Polychaeta')
    OR (phylum = 'Mollusca' AND class IN ('Bivalvia', 'Gastropoda'))
    OR (phylum = 'Echinodermata')
    OR (phylum = 'Arthropoda' AND class = 'Malacostraca')",
  
  corals = "phylum = 'Cnidaria'
    AND class IN ('Anthozoa', 'Hydrozoa')
    AND \"order\" IN ('Scleractinia', 'Alcyonacea')",
  
  pelagic_fish = "phylum = 'Chordata'
    AND class = 'Actinopterygii'
    AND \"order\" IN ('Clupeiformes', 'Perciformes', 'Gadiformes')
    AND family IN ('Scombridae', 'Clupeidae', 'Gadidae')",
  
  seabirds = "class = 'Aves'
    AND \"order\" IN ('Charadriiformes', 'Procellariiformes', 'Pelecaniformes')
    AND family IN ('Laridae', 'Procellariidae', 'Sulidae', 'Phalacrocoracidae')",
  
  turtles = "class = 'Reptilia'
    AND \"order\" = 'Testudines'
    AND family IN ('Cheloniidae', 'Dermochelyidae')",
  
  elasmo = "class = 'Chondrichthyes'
    AND (\"order\" IN ('Lamniformes', 'Carcharhiniformes', 'Rajiformes', 'Myliobatiformes')
    OR family IN ('Sphyrnidae', 'Pristidae', 'Mobulidae'))",
  
  other_fish = "phylum = 'Chordata'
    AND class = 'Actinopterygii'
    AND \"order\" NOT IN ('Clupeiformes', 'Perciformes', 'Gadiformes')
    AND family NOT IN ('Scombridae', 'Clupeidae', 'Gadidae')",
  
  other_inverts = "phylum IN ('Porifera', 'Bryozoa', 'Brachiopoda', 'Chaetognatha', 'Nemertea')
    OR (phylum = 'Arthropoda' AND class NOT IN ('Malacostraca'))
    OR (phylum = 'Mollusca' AND class NOT IN ('Bivalvia', 'Gastropoda'))"
)

# add column taxa if not already present
if (!("taxa" %in% dbListFields(con, tbl_ply_spp))) {
  dbExecute(con, glue("ALTER TABLE {tbl_ply_spp} ADD COLUMN taxa TEXT"))
}

# Assign taxa groupings to species
for (taxa in names(where_taxa)) { # taxa = names(where_taxa)[1]
  dbExecute(con, glue("UPDATE {tbl_ply_spp} SET taxa = '{taxa}' WHERE {where_taxa[[taxa]]}"))
}
```


```{r ck_ply_species_taxa}
# TODO: move to single species

d_pspp <- tbl(con, "ply_species") |>
  distinct(phylum, class, order, family, genus, species) |> 
  collect()

table(d_pspp$phylum)
table(d_pspp$class, useNA = "ifany")

with(
  d_pspp,
  table(phylum, class, useNA = "ifany"))


```


https://oceanhealthindex.org/images/htmls/Supplement.html#62_Biodiversity


## Visualize Species Data

### Flower Plot

```{r}
librarian::shelf(
  dplyr, ggiraph, ggplot2)

# Function to create the flower plot
plot_flower <- function(
    data,
    fld_category,
    fld_height,
    fld_width,
    tooltip_expr = NULL,
    score  = NULL,
    colors = "Set2"){
  
  stopifnot(is.numeric(data |> pull({{ fld_height }})))
  stopifnot(is.numeric(data |> pull({{ fld_width }})))

  if (is.null(score)){
    score <- data |> 
      # ensure both are not just integer (weighted.mean goes to 0)
      mutate(
        "{{fld_height}}" := as.double({{ fld_height }}),
        "{{fld_width}}"  := as.double({{ fld_width  }}) ) |> 
      summarize(
        score = weighted.mean({{ fld_height }}, {{ fld_width }}, na.rm = T)) |> 
      pull(score)
  }

  # Calculate positions
  d <- data |> 
    arrange({{ fld_category }}) |> 
    mutate(across(!where(is.character), as.double)) |> 
    mutate(
      # Calculate angles for plotting
      ymax    = cumsum({{ fld_width }}),
      ymin    = lag(ymax, default=0), # ,  c(0, head(ymax, n=-1)),
      xmax    = {{ fld_height }},
      xmin    = 0)
  
  sym_category <- ensym(fld_category)
  sym_height   <- ensym(fld_height)
  sym_width    <- ensym(fld_width)

  if (!is.null(tooltip_expr)){
    d <- d |> 
      mutate(
        tooltip = glue(tooltip_expr))
  } else {
    d <- d |> 
      mutate(
        tooltip = glue("{!!fld_category}"))
  }
  
  g <- ggplot(d) +
    geom_rect_interactive(aes(
      xmin    = xmin,
      xmax    = xmax,
      ymin    = ymin,
      ymax    = ymax,
      fill    = {{ fld_category }},
      color   = "white",
      data_id = {{ fld_category }},
      tooltip = tooltip),
      color = "white",
      alpha = 0.5) +
    coord_polar(theta = "y") +
    # Create donut hole
    xlim(c(-10, max(data |> pull({{ fld_height }})))) +
    # Add center score
    annotate(
      "text", x = -10, y = 0, 
      label = round(score), 
      size = 8, 
      fontface = "bold") +
    # Customize appearance
    scale_fill_brewer(
      palette = colors) +
    theme_minimal() +
    # theme_void() +
    theme(
      legend.position = "bottom",
      plot.margin = unit(c(20, 20, 20, 20), "pt"))

  girafe(ggobj = g)
}

i = 1
pa <- unique(d_pa$planarea_ukey)[i]
d_fl <- d_pa |> 
  filter(planarea_ukey == !!pa) |> 
  mutate(
    score_new = score_raw * 10000000,
    even = 1) |> 
  select(taxa, n_spp, score_raw, score_new, even)

d_fl |> 
  arrange(desc(taxa)) |> 
  plot_flower(
    fld_category = taxa,
    fld_height   = score_new,
    fld_width    = even,
    tooltip_expr = "{taxa}: {round(score_new, 2)} (n_spp: {n_spp})")

d_fl |> 
  plot_flower(
    fld_category = taxa,
    fld_height   = score_new,
    fld_width    = n_spp,
    tooltip_expr = "{taxa}: {round(score_new, 2)} (n_spp: {n_spp})")
```



### Species

## Calc scores by planareas

```{r}
#| label: calc_planareas

# source("libs/db.R")

# block group scores across ecoregion ----

# DEBUG
# pa <- "brAK_erGOA_paGEO" # (n = 7 blocks)
# er <- "brAK_erGOA" # (n = 7 blocks)
# 
# tbl(con, "ply_ecoblks") |> 
#   filter(planarea_key != "NA") |>
#   filter(ecorgn_ukey == er) |> 
#   group_by(ecorgn_ukey) |> 
#   summarize(
#     n = n()) |> 
#   pull(n)
# # 52,593
# 
# tbl(con, "ply_ecoblks") |>
#   summarize(n = n()) # 309,229
# tbl(con, "ply_ecoblks") |>
#   group_by(prodiag_ukey) |> 
#   summarize(n_bk = n()) |> 
#   summarize(
#     n_pd     = n(),
#     n_bk_avg = mean(n_bk),
#     n_bk_sd  = sd(n_bk),
#     n_bk_min = min(n_bk),
#     n_bk_max = max(n_bk))
#  n_pd n_bk_avg n_bk_sd n_bk_min n_bk_max
#   647     478.    368.        1     1122    
#   647 * 478 = 309,266

# ply_scores for ecoblks -----
keys <- tbl(con, "ply_ecoblks") |> 
  filter(planarea_key != "NA") |> 
  arrange(blk_ukey) |> 
  pull(blk_ukey)
# sum(duplicated(keys))
n_keys <- format(length(keys), big.mark=',')  # 309,229

# dbRemoveTable(con, "ply_scores")
t0 <- Sys.time()
i_step <- 100
i_seq <- seq(1, length(keys), by=i_step)
for (i in i_seq){ # i = 309001
  
  i_end <- min(i + i_step - 1, length(keys))
  keys_i <- keys[i:i_end]
  
  # if (i %% 10 == 0){
    #     300: AK_CBS_BFT_NR05-01_6659     ~ 2025-01-24 22:38:30.486211
    # 309,200: PAC_WAOR_WAO_NM10-07_7111   ~ 2025-01-25 08:58:55.109335
    t1     <- Sys.time() # t1 = as_datetime("2025-01-24 23:05:37.41435")
    i_togo <- length(keys) - i
    eta <- t1 + ((t1 - t0) / i) * i_togo
    message(glue(
      "{str_pad(format(i, big.mark=','), nchar(n_keys))}: {keys[i]}  ~ {format(Sys.time())}; ETA: {format(eta)}"))
  # }
  
  d_eb <- tbl(con, "ply_ecoblks") |> 
    # filter(planarea_key != "NA") |>
    filter(blk_ukey %in% !!keys_i) |> # DEBUG
    select(blk_ukey) |> 
    # head(1) |> collect() |> names() |> paste(collapse = ", ")
    left_join(
      tbl(con, "ply_species") |> 
        select(ply_key, sp_key, sp_area_km2 = area_km2, avg_suit),
      by = c("blk_ukey" = "ply_key")) |> 
    left_join(
      tbl(con, "spp") |> 
        select(sp_key_am, taxa = group_gmbi, iucnRedListCategory),
      by = c("sp_key" = "sp_key_am")) |> 
    mutate(
      iucn_score = case_match(
        iucnRedListCategory,
        # skipped: EX (extinct), NE (not evaluated), DD (data deficient), <NA> (not available)
        # https://oceanhealthindex.org/images/htmls/Supplement.html#62_Biodiversity
        "CR" ~ 1,       #  - CR: Critically Endangered	
        "EN" ~ 0.8,     #  - EN: Endangered	
        "VU" ~ 0.6,     #  - VU: Vulnerable
        "NT" ~ 0.4,     #  - NT: Near Threatened
        "LC" ~ 0.2)) |> #  - LC: Least Concern
    filter(!is.na(iucn_score)) |> 
    left_join(
      tbl(con, "ply_ecoblks") |> 
        select(blk_ukey, eb_area_km2 = area_km2), # TODO: blk_ukey -> ecoblk_ukey
      by = "blk_ukey") |>
    mutate(
      sp_area_pct = round(sp_area_km2 / eb_area_km2, 6)) |> 
    group_by(blk_ukey, taxa) |> 
    summarize(
      n_spp     = n(),
      sp_pct    = mean(sp_area_pct),
      sp_suit   = mean(avg_suit),
      sp_iucn   = mean(iucn_score),
      # avg_score_raw   = mean(sp_area_pct) * mean(avg_suit) * mean(iucn_score),
      score_raw = sum(sp_area_pct * avg_suit * iucn_score) / n(),
      .groups = "drop") |>
    arrange(blk_ukey, taxa) |> 
    collect() |> 
    mutate(
      ply_fld = "blk_ukey") |> 
    rename(ply_key = blk_ukey) |> 
    relocate(ply_fld)
  
  dbWriteTable(con, "ply_scores", d_eb, append = T)
}

# TODO: score (not raw), from ref

# q_ebs <- unique(d_eb_scores$blk_ukey) |> paste(collapse = "','")
# 
# tbl(con, "ply_ecoblks")
# ply_eb <- st_read(con, query = glue(
#   "SELECT blk_ukey, geom FROM ply_ecoblks WHERE blk_ukey IN ('{q_ebs}')"))
# d_s <- d_eb_scores |> 
#   # filter(is.na(score_raw))
#   group_by(taxa) |> 
#   summarize(
#     n         = n(),
#     score_avg = mean(score_raw),
#     score_sd  = sd(score_raw),
#     score_min = min(score_raw),
#     score_max = max(score_raw),
#     .groups = "drop")
# 
# d_eb_scores |> 
#   # arrange(taxa) |> 
#   filter(taxa == "Crustaceans") |> 
#   pull(score_raw) |> 
#   # head(7) |> 
#   sd()
# 
#   mutate(score_raw = round(score_raw, 4)) |> 
#   distinct(taxa, score_raw) |> 
#   arrange(taxa)
# d_eb_scores$taxa |> table()
# d_eb_scores |> 
#   filter(taxa == "Pinnipeds")

# planning area group scores ----

# d_pas <- tbl(con, "ply_ecoblks") |> 
#   filter(planarea_key != "NA") |>  # | prodiag_key  != "NA" | blk_key      != "NA") |> 
#   group_by(planarea_ukey) |> 
#   summarize(
#     n = n()) |> 
#   arrange(n)

# v_bks <- tbl(con, "ply_scores") |> 
#   pull(ply_key)
# v_pd <- str_replace(v_bks, ".*_pd(.+)_.*", "\\1")
# table(v_pd)
# v_pd
# brAK_erGOA_paGEO          NR05-01 
#              231           810084

# ply_scores for planareas -----
keys <- tbl(con, "ply_ecoblks") |> 
  filter(planarea_key != "NA") |> 
  distinct(planarea_ukey) |> 
  pull(planarea_ukey)
n_keys <- format(length(keys), big.mark=',')  # 309,229

t0 <- Sys.time()
for (i in 1:length(keys)){ # i <- which(keys == "brAK_erGOA_paGEO") # (n = 7 blocks)
  
  key <- keys[i]
  
  # if (i %% 10 == 0){
  #     300: AK_CBS_BFT_NR05-01_6659     ~ 2025-01-24 22:38:30.486211
  # 309,200: PAC_WAOR_WAO_NM10-07_7111   ~ 2025-01-25 08:58:55.109335
  t1     <- Sys.time() # t1 = as_datetime("2025-01-24 23:05:37.41435")
  i_togo <- length(keys) - i
  eta <- t1 + ((t1 - t0) / i) * i_togo
  message(glue(
    "{str_pad(format(i, big.mark=','), nchar(n_keys))}: {key}  ~ {format(Sys.time())}; ETA: {format(eta)}"))
  # }
  
  d_pa <- tbl(con, "ply_ecoblks") |> 
    filter(planarea_ukey == !!key) |>
    select(planarea_ukey, blk_ukey) |> 
    # head(1) |> collect() |> names() |> paste(collapse = ", ")
    left_join(
      tbl(con, "ply_species") |> 
        select(ply_key, sp_key, area_km2, avg_suit),
      by = c("blk_ukey" = "ply_key")) |> 
    group_by(planarea_ukey, sp_key) |> 
    summarize(
      sp_area_km2   = sum(area_km2),
      avg_suit   = mean(avg_suit * area_km2) / sum(area_km2),
      .groups = "drop") |> 
    left_join(
      tbl(con, "spp") |> 
        select(sp_key_am, taxa = group_gmbi, iucnRedListCategory),
      by = c("sp_key" = "sp_key_am")) |> 
    mutate(
      iucn_score = case_match(
        iucnRedListCategory,
        # skipped: EX (extinct), NE (not evaluated), DD (data deficient), <NA> (not available)
        # https://oceanhealthindex.org/images/htmls/Supplement.html#62_Biodiversity
        "CR" ~ 1,       #  - CR: Critically Endangered	
        "EN" ~ 0.8,     #  - EN: Endangered	
        "VU" ~ 0.6,     #  - VU: Vulnerable
        "NT" ~ 0.4,     #  - NT: Near Threatened
        "LC" ~ 0.2)) |> #  - LC: Least Concern
    filter(!is.na(iucn_score)) |> 
    left_join(
      tbl(con, "ply_eb_planareas") |> 
        select(planarea_ukey, pa_area_km2 = area_km2),
      by = "planarea_ukey") |>
    mutate(
      sp_area_pct = round(sp_area_km2 / pa_area_km2, 6)) |> 
    group_by(planarea_ukey, taxa) |> 
    summarize(
      n_spp      = n(),
      sp_pct     = mean(sp_area_pct),
      sp_suit    = mean(avg_suit),
      sp_iucn    = mean(iucn_score),
      score_raw  = sum(sp_area_pct * avg_suit * iucn_score) / n(),
      .groups = "drop") |>
    arrange(planarea_ukey, taxa) |> 
    collect() |> 
    mutate(
      ply_fld = "planarea_ukey") |> 
    rename(ply_key = planarea_ukey) |> 
    relocate(ply_fld)
  
  dbWriteTable(con, "ply_scores", d_pa, append = T)
}
```

```{r}
#| label: ply_scores_duckdb

librarian::shelf(
  arrow,
  marinebon/aquamapsduckdb, 
  duckdb, 
  mapview, tibble)
# devtools::load_all("~/Github/marinebon/aquamapsduckdb/")

source("~/Github/marinebon/aquamapsduckdb/inst/app/functions.R")

# ply_ecoblks_gpkg   <- here("data/ecoblks/ply_ecoblks.gpkg")
# ply_ecoblks_pq     <- here("data/ecoblks/ply_ecoblks.parquet")
# cells_gpkg         <- here("data/ecoblks/cells.gpkg")
msens_duckdb       <- here("data/ecoblks/msens.duckdb")

con_dd <- dbConnect(duckdb(dbdir = msens_duckdb, read_only = F))
# dbDisconnect(con_dd, shutdown = T)

dbExecute(con_dd, "INSTALL spatial; LOAD spatial; LOAD parquet; INSTALL postgres; LOAD postgres;")

# if (!file.exists(ply_ecoblks_gpkg)){
#   ply_ecoblks <- st_read(con, "ply_ecoblks") # 309,229 features, 13 fields
#   st_write(f_ecoblk, ply_ecoblks_gpkg)
#   
#   d_ecoblks <- f_ecoblk |> 
#     st_drop_geometry() |> 
#     tibble()
#   write_parquet(d_ecoblks, ply_ecoblks_pq)
# }

# dbListTables(con_dd)
# dbRemoveTable(con_dd, "ecoblk")
# dir_am_duckdb <- "/Users/bbest/My Drive/projects/msens/data/derived/aquamaps/am.duckdb_export" spp_cells_pq <- glue("{dir_am_duckdb}/spp_cells.parquet")
# dbExecute(con_dd, glue(
#   "CREATE VIEW spp_cells AS SELECT * FROM read_parquet('{spp_cells_pq}');"))
# dbGetQuery(con_dd, "DESCRIBE SELECT * FROM spp_cells")
# d_spp_cells <- dbGetQuery(con_dd, "SELECT * FROM spp_cells", n = 10)

# dbExecute(con_dd, glue(
#   "CREATE TABLE ply_ecoblks AS SELECT * FROM ST_Read('{ply_ecoblks_gpkg}')")) # 309,229
# eb_d <- dbGetQuery(con_dd, "DESCRIBE SELECT * FROM ecoblk LIMIT 3")

# https://duckdb.org/docs/extensions/postgres.html
dbExecute(con_dd, glue("ATTACH 'dbname=msens user=admin host=127.0.0.1 password={readLines(db_pass_txt)}' AS pg_am (TYPE POSTGRES, SCHEMA 'aquamaps');"))
dbExecute(con_dd, glue("ATTACH 'dbname=msens user=admin host=127.0.0.1 password={readLines(db_pass_txt)}' AS pg (TYPE POSTGRES, SCHEMA 'public');"))

lst_tbls <- list(
  "ply_ecoblks" = list(
    schema = "pg",
    flds   = "ecorgn_ukey, planarea_ukey, prodiag_ukey, blk_ukey, area_km2"),
  "ecoblk_cell" = list(
    schema = "pg",
    flds   = "blk_ukey, cell_id, area_km2"),
  "spp_cells" = list(
    schema = "pg_am",
    flds   = "cell_id, sp_key, probability"),
  "spp" = list(
    schema = "pg",
    flds   = "sp_key_am, group_gmbi, \"iucnRedListCategory\""))

for (tbl in names(lst_tbls)){
  pq <- glue(here("data/ecoblks/{tbl}.parquet"))
  
  if (file.exists(pq))
    next()
  
  with(lst_tbls[[tbl]],{
    q_pq <- glue(
      "COPY (SELECT {flds} FROM {schema}.{tbl} ORDER BY {flds}) TO '{pq}' (FORMAT 'parquet');")
    q_view <- glue(
      "CREATE VIEW {tbl} AS SELECT * FROM read_parquet('{pq}');")
    # q_ck <- glue("DESCRIBE SELECT * FROM {tbl}")
    # message(q_pq, "\n", q_view, "\n", q_ck)
    dbExecute(con_dd, q_pq)
    dbExecute(con_dd, q_view)
    # dbGetQuery(con_dd, q_ck)
  })
}
# dbExecute(con_dd, "DROP VIEW spp")

dbExecute(con_dd, "DETACH pg_am;")
dbExecute(con_dd, "DETACH pg;")
dbExecute(con_dd, "VACUUM;")
dbListTables(con_dd)
# "ecoblk_cell" "ply_ecoblks" "spp" "spp_cells"

# https://medium.com/radiant-earth-insights/duckdb-the-indispensable-geospatial-tool-you-didnt-know-you-were-missing-5fe11c5633e5
```


```{r}
#| label: duckdb_ply_spp

# blk TOO SLOW
# d_eb <- tbl(con, "ecoblk_cell") |> 
#   select(blk_ukey, cell_id, area_km2) |> 
#   left_join(
#     tbl(con, "spp_cells") |> 
#       select(cell_id, sp_key, probability),
#     by = "cell_id") |> 
#   group_by(blk_ukey, sp_key) |> 
#   summarize(
#     sp_km2  = sum(area_km2),
#     sp_suit = sum(probability * area_km2) / sum(area_km2),
#     .groups = "drop") |> 
#   mutate(
#     ply_fld = "blk_ukey",
#     ply_key = blk_ukey) |> 
#   select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
#   collect()

tic("prodiag")
d_pd <- tbl(con_dd, "ply_ecoblks") |>
  select(prodiag_ukey, blk_ukey) |> 
  left_join(
    tbl(con_dd, "ecoblk_cell") |> 
      select(blk_ukey, cell_id, area_km2),
    by = "blk_ukey") |> 
  left_join(
    tbl(con_dd, "spp_cells") |> 
      select(cell_id, sp_key, probability),
    by = "cell_id") |> 
  group_by(prodiag_ukey, sp_key) |> 
  summarize(
    sp_km2  = sum(area_km2),
    sp_suit = sum(probability * area_km2) / sum(area_km2),
    .groups = "drop") |> 
  mutate(
    ply_fld = "prodiag_ukey",
    ply_key = prodiag_ukey) |> 
  select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
  collect()
toc() # 2.774 sec

tic("planarea")
d_pa <- tbl(con_dd, "ply_ecoblks") |>
  select(planarea_ukey, blk_ukey) |> 
  left_join(
    tbl(con_dd, "ecoblk_cell") |> 
      select(blk_ukey, cell_id, area_km2),
    by = "blk_ukey") |> 
  left_join(
    tbl(con_dd, "spp_cells") |> 
      select(cell_id, sp_key, probability),
    by = "cell_id") |> 
  group_by(planarea_ukey, sp_key) |> 
  summarize(
    sp_km2  = sum(area_km2),
    sp_suit = sum(probability * area_km2) / sum(area_km2),
    .groups = "drop") |> 
  mutate(
    ply_fld = "planarea_ukey",
    ply_key = planarea_ukey) |> 
  select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
  collect()
toc() # 2.253 sec

tic("ecorgn")
d_er <- tbl(con_dd, "ply_ecoblks") |>
  select(ecorgn_ukey, blk_ukey) |> 
  left_join(
    tbl(con_dd, "ecoblk_cell") |> 
      select(blk_ukey, cell_id, area_km2),
    by = "blk_ukey") |> 
  left_join(
    tbl(con_dd, "spp_cells") |> 
      select(cell_id, sp_key, probability),
    by = "cell_id") |> 
  group_by(ecorgn_ukey, sp_key) |> 
  summarize(
    sp_km2  = sum(area_km2),
    sp_suit = sum(probability * area_km2) / sum(area_km2),
    .groups = "drop") |> 
  mutate(
    ply_fld = "ecorgn_ukey",
    ply_key = ecorgn_ukey) |> 
  select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
  collect()
toc() # 2.204 sec

d_all <- list(d_pd, d_pa, d_er) |> 
  bind_rows() |> 
  arrange(ply_fld, ply_key, sp_key)

ply_spp_pq <- here("data/ecoblks/ply_spp.parquet")
write_parquet(d_all, ply_spp_pq)
dbExecute(con_dd, glue(
  "CREATE VIEW ply_spp AS SELECT * FROM read_parquet('{ply_spp_pq}');"))
dbListTables(con_dd)
# "ecoblk_cell" "ply_ecoblks" "ply_spp"     "spp_cells"
```

```{r}
#| label: duckdb_ply_area

d_ply_area <- bind_rows(
  tbl(con, "ply_eb_ecorgns") |> 
    mutate(
      ply_fld = "ecorgn_ukey") |> 
    select(ply_fld, ply_key = ecorgn_ukey, area_km2) |> 
    collect(),
  tbl(con, "ply_eb_planareas") |> 
    mutate(
      ply_fld = "planarea_ukey") |> 
    select(ply_fld, ply_key = planarea_ukey, area_km2) |> 
    collect(),
  tbl(con, "ply_eb_prodiags") |> 
    mutate(
      ply_fld = "prodiag_ukey") |> 
    select(ply_fld, ply_key = prodiag_ukey, area_km2) |> 
    collect()) |> 
  arrange(ply_fld, ply_key)

ply_area_pq <- here("data/ecoblks/ply_area.parquet")
write_parquet(d_ply_area, ply_area_pq)
dbExecute(con_dd, glue(
  "CREATE VIEW ply_area AS SELECT * FROM read_parquet('{ply_area_pq}');"))
# dbListTables(con_dd)
# "ecoblk_cell" "ply_area"    "ply_ecoblks" "ply_spp"     "spp"         "spp_cells"  
```

```{r}
#| label: duckdb_ply_taxa

d_ply_taxa <- tbl(con_dd, "ply_spp") |> 
  filter(!is.na(sp_key)) |> 
  select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
  left_join(
    tbl(con_dd, "ply_area") |> 
      rename(ply_km2 = area_km2),
    by = c("ply_fld", "ply_key")) |> 
  mutate(
    sp_pct_ply = ifelse(sp_km2 / ply_km2 > 1, 1, sp_km2 / ply_km2)) |> 
  left_join(
    tbl(con_dd, "spp") |> 
      select(sp_key = sp_key_am, taxa = group_gmbi, iucn_cat = iucnRedListCategory),
    by = "sp_key") |> 
  mutate(
    iucn_score = case_match(
      iucn_cat,
      # skipped: EX (extinct), NE (not evaluated), DD (data deficient), <NA> (not available)
      # https://oceanhealthindex.org/images/htmls/Supplement.html#62_Biodiversity
      "CR" ~ 1,       #  - CR: Critically Endangered	
      "EN" ~ 0.8,     #  - EN: Endangered	
      "VU" ~ 0.6,     #  - VU: Vulnerable
      "NT" ~ 0.4,     #  - NT: Near Threatened
      "LC" ~ 0.2)) |> #  - LC: Least Concern
  # TODO: show species in app before filtering
  filter(!is.na(iucn_score)) |> 
  group_by(ply_fld, ply_key, taxa) |> 
  summarize(
    n_spp      = n(),
    sp_pct     = mean(sp_pct_ply),
    sp_suit    = mean(sp_suit),
    sp_iucn    = mean(iucn_score),
    score_raw  = sum(sp_pct_ply * sp_suit * iucn_score) / n(),
    .groups = "drop") |>
  arrange(ply_fld, ply_key, taxa) |> 
  collect()

d_ply_taxa$ply_fld |> table()
# ecorgn_ukey planarea_ukey  prodiag_ukey 
#          88           292          4793

librarian::shelf(purrr, scales)

d_ply_refs <- d_ply_taxa |> 
  mutate(
    ecorgn_ukey = str_extract(ply_key, "br[A-Z]+_er[A-Z]+")) |> 
  select(ecorgn_ukey, ply_key, taxa, score_raw) |> 
  group_by(ecorgn_ukey, taxa) |> 
  summarize(
    score_min = min(score_raw),
    score_max = max(score_raw),
    ply_key_min = ply_key[which.min(score_raw)],
    ply_key_max = ply_key[which.max(score_raw)],
    .groups = 'drop')

d_ply_taxa_scores <- d_ply_taxa |> 
  mutate(
    ecorgn_ukey = str_extract(ply_key, "br[A-Z]+_er[A-Z]+")) |> 
  left_join(
    d_ply_refs,
    by = c("ecorgn_ukey", "taxa")) |> 
  mutate(
    score = pmap_dbl(
      list(score_raw, score_min, score_max), 
      \(v, v_min, v_max) scales::rescale(v, to = c(0,1), from = c(v_min, v_max))))

d_ply_scores <- d_ply_taxa_scores |>
  group_by(ply_fld, ply_key) |> 
  summarize(
    score_nspp = sum(score * n_spp) / sum(n_spp),
    score_even = mean(score),
    .groups = "drop")

dbWriteTable(con, "ply_scores", d_ply_scores)

pa <- st_read(con, "ply_planareas") |> 
  mutate(
    planarea_ukey = glue("{boemrgn_key}_")
  )

d_ply_scores |> 
  filter(ply_fld == "planarea_ukey")

eb <- st_read(con, "ply_ecoblks")
eb |> 
  filter(planarea_key == "SOA") |> 
  mapView()
pas_eb <- eb |> distinct(planarea_key) |> pull(planarea_key)
  



pas_pa0 <- pa0 |> distinct(planarea_key) |> pull(planarea_key)
pa0 |>
  filter(planarea_key %in% c("paFLS","paSOA")) |> 
  mapView()
  st_drop_geometry() |> 
  distinct(planarea_key, planarea_name) |> 
  filter(planarea_key == "paSOA")
  

pa1 <- st_read(con, "ply_eb_planareas") |> 
  filter(planarea_key == "SOA") |> mapView()

# d_ply_scores |> 
#   pull(score) |>
#   hist()

```

```{r}
#| label: pgprot_ply_area

d_ply_area <- bind_rows(
  tbl(con, "ply_ep_ecorgns") |> 
    mutate(
      ply_fld = "ecorgn_ukey") |> 
    select(ply_fld, ply_key = ecorgn_ukey, area_km2) |> 
    collect(),
  tbl(con, "ply_ep_planareas") |> 
    mutate(
      ply_fld = "planarea_ukey") |> 
    select(ply_fld, ply_key = planarea_ukey, area_km2) |> 
    collect(),
  tbl(con, "ply_ecoprot") |> 
    mutate(
      ply_fld = "prodiag_ukey") |> 
    select(ply_fld, ply_key = prodiag_ukey, area_km2) |> 
    collect()) |> 
  arrange(ply_fld, ply_key)

dbWriteTable(con, "ply_area", d_ply_area)
# dbListTables(con_dd)
# "ecoblk_cell" "ply_area"    "ply_ecoblks" "ply_spp"     "spp"         "spp_cells"  
```

```{r}
#| label: pgprot_ply_taxa

d_ply_taxa <- tbl(con, "ply_spp") |> 
  filter(!is.na(sp_key)) |> 
  select(ply_fld, ply_key, sp_key, sp_km2, sp_suit) |> 
  left_join(
    tbl(con, "ply_area") |> 
      rename(ply_km2 = area_km2),
    by = c("ply_fld", "ply_key")) |> 
  mutate(
    sp_pct_ply = ifelse(sp_km2 / ply_km2 > 1, 1, sp_km2 / ply_km2)) |> 
  left_join(
    tbl(con, "spp") |> 
      select(sp_key = sp_key_am, taxa = group_gmbi, iucn_cat = iucnRedListCategory),
    by = "sp_key") |> 
  mutate(
    iucn_score = case_match(
      iucn_cat,
      # skipped: EX (extinct), NE (not evaluated), DD (data deficient), <NA> (not available)
      # https://oceanhealthindex.org/images/htmls/Supplement.html#62_Biodiversity
      "CR" ~ 1,       #  - CR: Critically Endangered	
      "EN" ~ 0.8,     #  - EN: Endangered	
      "VU" ~ 0.6,     #  - VU: Vulnerable
      "NT" ~ 0.4,     #  - NT: Near Threatened
      "LC" ~ 0.2)) |> #  - LC: Least Concern
  # TODO: show species in app before filtering
  filter(!is.na(iucn_score)) |> 
  group_by(ply_fld, ply_key, taxa) |> 
  summarize(
    n_spp      = n(),
    sp_pct     = mean(sp_pct_ply),
    sp_suit    = mean(sp_suit),
    sp_iucn    = mean(iucn_score),
    score_raw  = sum(sp_pct_ply * sp_suit * iucn_score) / n(),
    .groups = "drop") |>
  arrange(ply_fld, ply_key, taxa) |> 
  collect()

d_ply_taxa$ply_fld |> table()
# ecorgn_ukey planarea_ukey  prodiag_ukey 
#          98           298          4852

librarian::shelf(purrr, scales)

d_ply_refs <- d_ply_taxa |> 
  mutate(
    ecorgn_ukey = str_extract(ply_key, "br[A-Z]+_er[A-Z]+")) |> 
  select(ecorgn_ukey, ply_key, taxa, score_raw) |> 
  group_by(ecorgn_ukey, taxa) |> 
  summarize(
    score_min = min(score_raw),
    score_max = max(score_raw),
    ply_key_min = ply_key[which.min(score_raw)],
    ply_key_max = ply_key[which.max(score_raw)],
    .groups = 'drop')

d_ply_taxa_scores <- d_ply_taxa |> 
  mutate(
    ecorgn_ukey = str_extract(ply_key, "br[A-Z]+_er[A-Z]+")) |> 
  left_join(
    d_ply_refs,
    by = c("ecorgn_ukey", "taxa")) |> 
  mutate(
    score = pmap_dbl(
      list(score_raw, score_min, score_max), 
      \(v, v_min, v_max) scales::rescale(v, to = c(0,1), from = c(v_min, v_max))))
# table(d_ply_taxa_scores$ply_fld)
#   ecorgn_ukey planarea_ukey  prodiag_ukey 
#            98           298          4852
dbWriteTable(con, "ply_taxa_scores", d_ply_taxa_scores)

d_ply_scores <- d_ply_taxa_scores |>
  group_by(ply_fld, ply_key) |> 
  summarize(
    score_nspp = sum(score * n_spp) / sum(n_spp),
    score_even = mean(score),
    .groups = "drop")
# table(d_ply_scores$ply_fld)
#   ecorgn_ukey planarea_ukey  prodiag_ukey 
#            10            35           669
# dbExecute(con, "ALTER TABLE ply_scores RENAME TO ply_scores_preprot")
dbWriteTable(con, "ply_scores", d_ply_scores)
```

```{r}
#| label: pgprot_scores_to_ply

tbls <- c(
  "ply_ecoprot"      = "prodiag_ukey",
  "ply_ep_planareas" = "planarea_ukey",
  "ply_ep_ecorgns"   = "ecorgn_ukey")

for (tbl in names(tbls)){ # tbl = names(tbls)[2]
  fld <- tbls[[tbl]]
  
  dbExecute(con, glue("ALTER TABLE {tbl} ADD COLUMN IF NOT EXISTS score_nspp FLOAT8"))
  dbExecute(con, glue("ALTER TABLE {tbl} ADD COLUMN IF NOT EXISTS score_even FLOAT8"))
  dbExecute(con, glue("
    UPDATE {tbl} p
    SET score_nspp = s.score_nspp,
        score_even = s.score_even
    FROM ply_scores s
    WHERE p.{fld} = s.ply_key"))
}

d_ply_scores |> 
  filter(ply_fld == "planarea_ukey") |> 
  # pull(score_nspp) # TODO: fix all 0s!
  pull(score_even)s
p_pa <- st_read(con, "ply_ep_planareas")
p_pa |> 
  select(planarea_ukey, score_even)

p_pa |> 
  st_shift_longitude() |> 
  mapView(zcol = "score_even")


tbl(con, "ply_ep_planareas") |> 
  select(planarea_ukey, score_even)

p_pa |> 
  select(planarea_ukey) |> 
  left_join(
    d_ply_scores |> 
      select(ply_key, score_even),
    by = c("planarea_ukey" = "ply_key")) |> 
  # st_wrap_dateline() |> 
  st_shift_longitude() |> 
  mapView(zcol = "score_even")

```


```{sql}


CREATE OR REPLACE
FUNCTION public.countries_name(
            z integer, x integer, y integer,
            name_prefix text default 'B')
RETURNS bytea
AS $$
DECLARE
    result bytea;
BEGIN
    WITH
    bounds AS (
      SELECT ST_TileEnvelope(z, x, y) AS geom
    ),
    mvtgeom AS (
      SELECT ST_AsMVTGeom(ST_Transform(t.geom, 3857), bounds.geom) AS geom,
        t.name
      FROM ne_50m_admin_0_countries t, bounds
      WHERE ST_Intersects(t.geom, ST_Transform(bounds.geom, 4326))
      AND upper(t.name) LIKE (upper(name_prefix) || '%')
    )
    SELECT ST_AsMVT(mvtgeom, 'default')
    INTO result
    FROM mvtgeom;

    RETURN result;
END;
$$
LANGUAGE 'plpgsql'
STABLE
PARALLEL SAFE;

COMMENT ON FUNCTION public.countries_name IS 'Filters the countries table by the initial letters of the name using the "name_prefix" parameter.';
```


```{r}
#| label: faster pa ply_scores

pa <- "brAK_erCBS_paBFT"

dbGetQuery(con, "SELECT count(*) AS nrow FROM public.ply_species")
# 279,226,334
dbGetQuery(con, "SELECT reltuples::bigint AS estimate FROM pg_class where relname = 'ply_species'")

tbl(con, "ply_ecoblks") |> 
  filter(planarea_ukey == pa) |> 
  select(planarea_ukey, blk_ukey, area_km2) |> 
  left_join(
    tbl(con, "ply_scores"), 
    by = c("blk_ukey" = "ply_key")) |> 
  group_by(planarea_ukey, taxa) |> 
  summarize(
    
  )

```


```{r}
#| label: calc scores from score_raw

# source("libs/db.R")
tbl(con, "ply_scores") |> 
  group_by(ply_fld) |> 
  summarize(n = n())

er <- "brAK_erCBS"
d_eb <- tbl(con, "ply_ecoblks") |> 
  filter(ecorgn_ukey == er) |> 
  select(ecorgn_ukey, blk_ukey) |> 
  left_join(
    tbl(con, "ply_scores") |> 
      filter(ply_fld == "blk_ukey"), 
    by = c("blk_ukey" = "ply_key")) |> 
  group_by(ecorgn_ukey, taxa) |> 
  summarize(
    # er_n         = n(),
    er_score_min = min(score_raw),
    er_score_max = max(score_raw),
    # er_score_avg = mean(score_raw),
    # er_score_sd  = sd(score_raw),
    .groups = "drop")

tbl(con, "ply_eb_planareas") |> 
  filter(ecorgn_ukey == "brAK_erCBS") |> 
  pull(planarea_ukey)
# "brAK_erCBS_paBFT" "brAK_erCBS_paCHU" "brAK_erCBS_paHOP" "brAK_erCBS_paNOR"

d_pa <- tbl(con, "ply_eb_planareas") |> 
  filter(ecorgn_ukey == !!er) |> 
  select(ecorgn_ukey, planarea_ukey) |> 
  left_join(
    tbl(con, "ply_scores") |> 
      filter(ply_fld == "planarea_ukey"), 
    by = c("planarea_ukey" = "ply_key")) |> 
  left_join(
    tbl(con, "ply_ecoblks") |> 
      filter(ecorgn_ukey == er) |> 
      select(ecorgn_ukey, blk_ukey) |> 
      left_join(
        tbl(con, "ply_scores") |> 
          filter(ply_fld == "blk_ukey"), 
        by = c("blk_ukey" = "ply_key")) |> 
      group_by(ecorgn_ukey, taxa) |> 
      summarize(
        # er_n         = n(),
        er_score_min = min(score_raw),
        er_score_max = max(score_raw),
        # er_score_avg = mean(score_raw),
        # er_score_sd  = sd(score_raw),
        .groups = "drop"),
    by = c("ecorgn_ukey", "taxa")) |> 
  collect()

library(scales)
library(purrr)
d_pa |> 
  arrange(taxa, planarea_ukey) |> 
  mutate(
    score = pmap_dbl(
      list(score_raw, er_score_min, er_score_max), 
      \(s, s_min, s_max) rescale(s, to = c(s_min, s_max)))) |> 
  select(taxa, planarea_ukey, score_raw, er_score_min, er_score_max, score)

  
  
```



```{r ply_iucn}
ply_key <- "erCAC-paCEC"

# get species data from db
schema       = "public"
tbl          = "ply_ecoareas"
fld_key      = "ecoarea_key"
tbl_ply_spp  = "ply_species"

d_ply_spp <- tbl(con, "ply_species") |> 
  group_by(ply_key) |> 
  summarize(n = n()) |> 
  collect()
# View(d_ply_spp)

d_spp <- dbGetQuery(con, glue(
  "SELECT * FROM {tbl_ply_spp} 
  WHERE
    ply_tbl = '{schema}.{tbl}' AND 
    ply_fld = '{fld_key}'      AND 
    ply_key = '{ply_key}'")) |> 
  replace_na(list(taxa = "other_taxa")) |> 
  # mutate(
  #   taxa = factor(taxa, levels = sort(names(where_taxa))) |> 
  #     forcats::fct_na_value_to_level("other_taxa")) |> 
  tibble()

tbl(con, tbl_ply_spp) |> 
  group_by(ply_fld) |> 
  summarize(n = n()) |> 
  collect()
#   ply_fld           n
# 1 ecoarea_key   94667
# 2 ecorgn_key    37596

# d_rlcat <- tbl(con, "spp") |> 
#   select(sp_id_gbif, iucnRedListCategory) |> 
#   group_by(iucnRedListCategory) |>
#   summarize(n = n()) |> 
#   arrange(iucnRedListCategory) |> 
#   collect()

d_spp_iucn <- tbl(con, "ply_species") |> 
  rename(sp_key_am = sp_key) |> 
  filter(
    ply_key == !!ply_key) |>   
  replace_na(list(
    taxa = "other_taxa")) |>   
  left_join(
    tbl(con, "spp") |> 
      # filter(!is.na(iucnRedListCategory)) |> 
      select(sp_key_am, sp_id_gbif, iucnRedListCategory) |> 
      mutate(
        iucn_score = case_match(
          iucnRedListCategory,
          # skipped: EX (extinct), NE (not evaluated), DD (data deficient), <NA> (not available)
          # https://oceanhealthindex.org/images/htmls/Supplement.html#62_Biodiversity
          "CR" ~ 1,     #  - CR: Critically Endangered	
          "EN" ~ 0.8,   #  - EN: Endangered	
          "VU" ~ 0.6,   #  - VU: Vulnerable
          "NT" ~ 0.4,   #  - NT: Near Threatened
          "LC" ~ 0.2)), #  - LC: Least Concern
    # |> filter(!is.na(iucn_score))
    by = "sp_key_am") |> 
  filter(!is.na(iucn_score)) |> 
  group_by(taxa) |> 
  summarize(
    n_spp      = n(),
    amt        = sum(area_km2 * avg_suit, na.rm=T),
    amt_per_sp = sum(area_km2 * avg_suit, na.rm=T) / n(),
    iucn_score = sum(iucn_score * area_km2 * avg_suit, na.rm=T) / sum(area_km2 * avg_suit, na.rm=T)) |> 
  arrange(taxa) |> 
  collect() # |> 
# View(d_spp_iucn)
# ply_key <- "erCAC-paCEC"
# d_spp_iucn
# # A tibble: 8 × 5
#   taxa            n_spp     amt amt_per_sp iucn_score
#   <chr>         <int64>   <dbl>      <dbl>      <dbl>
# 1 benthos           701  3218.        4.59      0.467
# 2 corals             21   100.        4.78     NA    
# 3 mammals            31  1017.       32.8       0.286
# 4 other_fish        533 12543.       23.5       0.214
# 5 other_inverts     189  1989.       10.5       0.2  
# 6 other_taxa        586  4639.        7.92      0.302
# 7 pelagic_fish       18   280.       15.6       0.246
# 8 turtles             3    69.4      23.1       0.6  
#
# ply_key <- "erCAC"
# d_spp_iucn
# # A tibble: 8 × 5
#   taxa            n_spp    amt amt_per_sp iucn_score
#   <chr>         <int64>  <dbl>      <dbl>      <dbl>
# 1 benthos          1742 21453.       12.3      0.365
# 2 corals             52   776.       14.9      0.24 
# 3 mammals            32  4498.      141.       0.283
# 4 other_fish        763 55395.       72.6      0.211
# 5 other_inverts     269 10515.       39.1      0.205
# 6 other_taxa       1004 25611.       25.5      0.272
# 7 pelagic_fish       23  1306.       56.8      0.238
# 8 turtles             3   299.       99.6      0.6  

d_spp_iucn |> 
  plot_flower(
    fld_category = taxa,
    fld_height   = iucn_score,
    fld_width    = n_spp)

with(
  d_spp_iucn,
  mean(iucn_score))  # 0.3338977
with(
  d_spp_iucn,
  # sum(n_spp * iucn_score) / sum(n_spp)) # 0.285
  # weighted.mean(iucn_score, n_spp, na.rm = T))  # 0 
  weighted.mean(iucn_score, as.double(n_spp), na.rm = T))                    # 0.2828092
weighted.mean(d_spp_iucn$iucn_score, as.double(d_spp_iucn$n_spp), na.rm = T) # 0.2828092

```

- [ply\_boemrgns](https://tile.marinesensitivity.org/public.ply_boemrgns.html#1.94/56.48/-114.43)
- [ply\_ecorgns](https://tile.marinesensitivity.org/public.ply_ecorgns.html#0.94/57.3/0)
- [ply\_planareas](https://tile.marinesensitivity.org/public.ply_planareas.html#0.94/57.3/0)
- [ply\_ecoareas](https://tile.marinesensitivity.org/public.ply_ecoareas.html#0.94/60.9/-93.9)
- [pg\_tileserv: raw.boem\_pc\_blk\_clp](https://tile.marinesensitivity.org/raw.boem_pc_blk_clp.html#4.01/39.93/-123.72)
- [pg\_tileserv: raw.boem\_gom\_blk\_clp](https://tile.marinesensitivity.org/raw.boem_gom_blk_clp.html#5.41/27.082/-89.174)
- [pg\_tileserv: raw.boem\_atl\_blk\_clp](https://tile.marinesensitivity.org/raw.boem_atl_blk_clp.html#3.91/34.97/-73.55)
- [pg\_tileserv: raw.boem\_ak\_blk\_clp](https://tile.marinesensitivity.org/raw.boem_ak_blk_clp.html#0.94/61.3/0)

```{r}



```


$$
amt = n\_cells * avg\_pct * avg\_suit
$$

Amount ($amt$) is the multiplication of the number of cells ($n\_cells$), average percent ($avg\_pct$) of a cell's contents within the selected polygon, and the average Suitability ($avg\_suit$; 0 to 100%) of the species given by AquaMaps.


## Get GBIF occurrences, with iucnRedListCategory

```{r}
librarian::shelf(
  DBI, dplyr, dbplyr, glue, here, 
  # furrr, 
  janitor, purrr, 
  readr, stringr, tictoc, tidyr, rgbif)
source("libs/db.R")

# plan(multicore, workers = availableCores())

if (!"spp" %in% dbListTables(con)){
  # species in ecoareas
  d_spp <- tbl(con, "ply_species") |> 
    filter(ply_tbl == "public.ply_ecoareas") |> 
    # distinct(sp_key, phylum, class, order, family, genus, species) |> 
    mutate(
      am_key   = sp_key,     # AquaMaps key
      rank     = "species",
      sci_name = paste(genus, species)) |> 
    distinct(sci_name, am_key, rank, phylum) |> 
    arrange(sci_name) |>
    collect() |> 
    relocate(sci_name)
  
  # GBIF taxon keys for species
  d_spp_ck <- name_backbone_checklist(d_spp |> select(-am_key))
  # table(d_spp_cklist$confidence)
  # 85    91    95    96    97    98    99   100 
  #  1    10     1    10     8    10    74 10462 
  # sum(is.na(d_spp_cklist$usageKey)) # 0
  
  # add am_key back
  d_spp_ck <- d_spp_ck |> 
    left_join(
      d_spp |> 
        select(am_key, sci_name),
      by = c("verbatim_name" = "sci_name")) |> 
    relocate(am_key)
  
  dbWriteTable(con, Id(schema = "public", table = "spp"), d_spp_ck, append = FALSE, row.names = F)
  
  # comment on table with source (this script) and date created
  dbExecute(
    con,
    sprintf(
    "COMMENT ON TABLE %s IS '%s';", 
    "spp", 
    paste("Created by [workflows: calc\\_ply\\_spp.qmd](https://github.com/MarineSensitivity/workflows/blob/main/calc_ply_spp.qmd)", "Date:", Sys.Date())))
  
  # rename columns in table spp: am_key -> sp_key_am, usageKey -> sp_id_gbif 
  if ("am_key" %in% dbListFields(con, "occ_species"))
    dbExecute(con,"ALTER TABLE spp RENAME COLUMN am_key TO sp_key_am")
  if ("usageKey" %in% dbListFields(con, "occ_species"))
    dbExecute(con,"ALTER TABLE spp RENAME COLUMN \"usageKey\" TO sp_id_gbif")

}

d_spp <- tbl(con, "spp") |> 
  select(am_key, verbatim_name, usageKey) |> 
  collect()

# https://docs.ropensci.org/rgbif/articles/downloading_a_long_species_list.html
# download the data
# SIMPLE_CSV
occ_download(
  pred_in("taxonKey", d_spp$usageKey[1:3]), # important to use pred_in
  pred("hasCoordinate", TRUE),
  pred("hasGeospatialIssue", FALSE),
  format = "SIMPLE_CSV")
```

```
<<gbif download>>
  Your download is being processed by GBIF:
  https://www.gbif.org/occurrence/download/0047937-241126133413365
  Most downloads finish within 15 min.
  Check status with
  occ_download_wait('0047937-241126133413365')
  After it finishes, use
  d <- occ_download_get('0047937-241126133413365') %>%
    occ_download_import()
  to retrieve your download.
Download Info:
  Username: ecoquants
  E-mail: ben@ecoquants.com
  Format: SIMPLE_CSV
  Download key: 0047937-241126133413365
  Created: 2024-12-24T21:28:09.639+00:00
Citation Info:  
  Please always cite the download DOI when using this data.
  https://www.gbif.org/citation-guidelines
  DOI: 10.15468/dl.wan8a3
  Citation:
  GBIF Occurrence Download https://doi.org/10.15468/dl.wan8a3 Accessed from R via rgbif (https://github.com/ropensci/rgbif) on 2024-12-24
```

```{r}
d_occ_csv <- occ_download_get('0047937-241126133413365') %>%
    occ_download_import()

occ_download(
  pred_in("taxonKey", d_spp$usageKey[1:3]), # important to use pred_in
  pred("hasCoordinate", TRUE),
  pred("hasGeospatialIssue", FALSE),
  format = "DWCA")

d_occ_dwca <- occ_download_get('0047938-241126133413365') %>%
  occ_download_import()

setdiff(names(d_occ_csv), names(d_occ_dwca))
# [1] "verbatimScientificNameAuthorship" "publishingOrgKey"     

setdiff(names(d_occ_dwca), names(d_occ_csv))
# [1] "verbatimScientificNameAuthorship" "publishingOrgKey"     

```

```
<<gbif download>>
  Your download is being processed by GBIF:
  https://www.gbif.org/occurrence/download/0047938-241126133413365
  Most downloads finish within 15 min.
  Check status with
  occ_download_wait('0047938-241126133413365')
  After it finishes, use
  d <- occ_download_get('0047938-241126133413365') %>%
    occ_download_import()
  to retrieve your download.
Download Info:
  Username: ecoquants
  E-mail: ben@ecoquants.com
  Format: DWCA
  Download key: 0047938-241126133413365
  Created: 2024-12-24T21:29:23.127+00:00
Citation Info:  
  Please always cite the download DOI when using this data.
  https://www.gbif.org/citation-guidelines
  DOI: 10.15468/dl.f8guzv
  Citation:
  GBIF Occurrence Download https://doi.org/10.15468/dl.f8guzv Accessed from R via rgbif (https://github.com/ropensci/rgbif) on 2024-12-24
```

```{r}
occ_download(
  pred_in("taxonKey", d_spp$usageKey), # important to use pred_in
  pred("hasCoordinate", TRUE),
  pred("hasGeospatialIssue", FALSE),
  format = "DWCA")
```

```
<<gbif download>>
  Your download is being processed by GBIF:
  https://www.gbif.org/occurrence/download/0047939-241126133413365
  Most downloads finish within 15 min.
  Check status with
  occ_download_wait('0047939-241126133413365')
  After it finishes, use
  d <- occ_download_get('0047939-241126133413365') %>%
    occ_download_import()
  to retrieve your download.
Download Info:
  Username: ecoquants
  E-mail: ben@ecoquants.com
  Format: DWCA
  Download key: 0047939-241126133413365
  Created: 2024-12-24T21:33:35.585+00:00
Citation Info:  
  Please always cite the download DOI when using this data.
  https://www.gbif.org/citation-guidelines
  DOI: 10.15468/dl.sspeuj
  Citation:
  GBIF Occurrence Download https://doi.org/10.15468/dl.sspeuj Accessed from R via rgbif (https://github.com/ropensci/rgbif) on 2024-12-24
```

GBIF Occurrence Download https://doi.org/10.15468/dl.sspeuj Accessed from R via rgbif (https://github.com/ropensci/rgbif) on 2024-12-24

```{r}
librarian::shelf(
  dplyr, glue, here, httr2, jsonlite, purrr, readr, rgbif, 
  # ropensci/rredlist, 
  tictoc, tidyr, utils)
source(here("libs/db.R"))

# DEBUG
# options(error=browser) # options(error=NULL)

dir_dl  <- "/share/data/gbifdownload"
dl_key  <- "0047939-241126133413365"
dl_zip  <- glue("{dir_dl}/{dl_key}.zip")
dl_dir  <- glue("{dir_dl}/{dl_key}")
occ_txt <- glue("{dir_dl}/{dl_key}/occurrence.txt")
tbl_spp <- "occ_species"
tbl_occ <- "occs"
# TODO: change on server vs laptop

dir_private <- switch(
  Sys.info()[["sysname"]],
  Darwin = "/Users/bbest/My Drive/private",  # laptop
  Linux  = "/share/private")                 # server
iucn_token_txt <- glue("{dir_private}/iucnredlist.org_api_token_v4.txt")
Sys.setenv(IUCN_REDLIST_KEY = readLines(iucn_token_txt))
# Sys.getenv("IUCN_REDLIST_KEY")

# # red_list_categories ----
# resp <- request("https://api.iucnredlist.org/api/v4/") |>
#   req_headers(Authorization = tkn_v4) |> 
#   req_url_path_append("red_list_categories") |>
#   req_perform()
# 
# d_rlcats <- resp |> 
#   resp_body_json() |>
#   pluck("red_list_categories") |>
#   map_dfr(~ tibble(
#     version     = .x$version, # latest: 3.1
#     code        = .x$code,
#     description = .x$description$en))
# View(d_rlcats)
# 
# # habitats ----
# resp <- request("https://api.iucnredlist.org/api/v4/") |>
#   req_headers(Authorization = tkn_v4) |> 
#   req_url_path_append("habitats") |>
#   req_perform()
# 
# d_rlhabs <- resp |> 
#   resp_body_json() |>
#   pluck("habitats") |>
#   map_dfr(~ tibble(
#     code        = .x$code,
#     description = .x$description$en))
# 
# View(d_rlhabs)
# 
# # habitats. 9 Marine Neritic ----
# resp <- request("https://api.iucnredlist.org/api/v4/") |>
#   req_headers(Authorization = tkn_v4) |> 
#   req_url_path_append("habitats", 9) |>
#   req_url_query(page = 1) |>
#   req_perform()
# 
# d_rlhab9p1 <- resp |> 
#   resp_body_json() |>
#   pluck("assessments") |>
#   map_dfr(~ tibble(
#     code        = .x$code,
#     description = .x$description$en))

if (!file.exists(dl_zip))
  occ_download_get(dl_key, path = dir_dl)
if (!file.exists(dl_dir))
  unzip(dl_zip, exdir = dl_dir)

read_tsv_chunked(
  occ_txt,
  SideEffectChunkCallback$new(
    \(d, pos){
      message(glue("pos: {pos}"))
      
      # glue("{ncol(d)}: {names(d)}") |> paste(collapse = ",\n") |> cat()
      # paste(names(d), collapse = ",\n") |> cat()
      
      # split into columns for taxa vs occurrences
      d_spp <- d |> 
        group_by(
          taxonKey, 
          taxonRank,
          kingdom,
          kingdomKey,
          phylum,
          phylumKey,
          class,
          classKey,
          order,
          orderKey,
          family,
          familyKey,
          genus,
          genusKey,
          subgenus,
          subgenusKey,
          species,
          speciesKey,
          iucnRedListCategory) |> 
        summarize(.groups = "drop")
      
      stopifnot(length(setdiff(unique(d$taxonKey), d_spp$taxonKey)) == 0)
      #stopifnot(sum(duplicated(d_spp$taxonKey)) == 0)
      # TODO: remove duplicate taxonKey
      # TODO: add AquaMaps key sp_key_am (*) vs sp_id_gbif (#) vs sp_key (GBIF:#, AM:*)
      # TODO: rename columns janitor clean style

      if (tbl_spp %in% dbListTables(con)){
        is_tbl_spp_new <- F
        taxonKeys_done <- tbl(con, tbl_spp) |> 
          pull(taxonKey)
        d_spp <- d_spp |> 
          filter(!taxonKey %in% taxonKeys_done)
      } else{
        is_tbl_spp_new <- T
      }
      dbWriteTable(con, tbl_spp, d_spp, append = TRUE, row.names = FALSE)
      
      if (is_tbl_spp_new){
        # TODO: add unique index for taxonKey and convert to long number 
      }
      
      d_occ <- d |> 
        select(
          gbifID, basisOfRecord, 
          taxonKey,
          decimalLatitude, decimalLongitude, coordinateUncertaintyInMeters,
          eventDate, year, month,
          elevation, elevationAccuracy, depth, depthAccuracy,
          datasetKey, lastParsed,
          issue)
      dbWriteTable(con, tbl_occ, d_occ, append = TRUE, row.names = FALSE)
      
    }),
  progress = F)
```

## IUCN RedList, API v4

```{r redlist}

if ("taxonKey" %in% dbListFields(con, "occ_species"))
  dbExecute(
    con,
    "ALTER TABLE occ_species RENAME COLUMN \"taxonKey\" TO sp_id_gbif")

if ("sp_key_gbif" %in% dbListFields(con, "occ_species"))
  dbExecute(
    con,
    "ALTER TABLE occ_species RENAME COLUMN sp_key_gbif TO sp_id_gbif")

if ("sp_key_gbif" %in% dbListFields(con, "spp"))
  dbExecute(
    con,
    "ALTER TABLE spp RENAME COLUMN sp_key_gbif TO sp_id_gbif")

# d_occ_spp <- tbl(con, "spp") |> 
#   select(sp_id_gbif) |> 
#   left_join(
#     tbl(con, "occ_species") |> 
#       distinct(sp_id_gbif, iucnRedListCategory),
#     by = "sp_id_gbif") |> 
#   collect() |> 
#   pull(iucnRedListCategory) |> 
#   table(useNA = "ifany")
# table(d_occ_spp$iucnRedListCategory, useNA = "ifany")
# CR   DD   EN   EX     LC     NE   NT   VU   <NA> 
# 25  114   41    1  1,827  5,157   52   92  3,267
# NE: not evaluated
# <NA>: no occurrences

# add text field iucnRedListCategory to table spp
if (!"iucnRedListCategory" %in% dbListFields(con, "spp"))
  dbExecute(con, "ALTER TABLE spp ADD COLUMN \"iucnRedListCategory\" TEXT")

# update table spp with iucnRedListCategory from table occ_species
dbExecute(
  con,
  "UPDATE spp
    SET \"iucnRedListCategory\" = occ_species.\"iucnRedListCategory\"
    FROM occ_species 
    WHERE occ_species.sp_id_gbif = spp.sp_id_gbif")

# tbl(con, "spp") |> 
#   pull(iucnRedListCategory) |> 
#   table(useNA = "ifany")
# CR   DD   EN   EX   LC   NE   NT   VU <NA> 
# 25  114   41    1 1827 5157   52   92 3267
  
# TODO: fix duplicates
species_xx <- tbl(con, "spp") |> 
  collect() |> 
  filter(duplicated(species)) |> 
  pull(species)
scientificName_xx <- tbl(con, "spp") |> 
  collect() |> 
  filter(duplicated(scientificName)) |> 
  pull(scientificName) # has ({author}, {year})
# length(scientificName_xx)  # 0
canonicalName_xx <- tbl(con, "spp") |> 
  collect() |> 
  filter(duplicated(canonicalName)) |> 
  pull(canonicalName)
# length(canonicalName_xx)  # 0
d_xx <- tbl(con, "spp") |> 
  filter(species %in% species_xx) |> 
  arrange(species) |> 
  collect()
table(d_xx$status)
# ACCEPTED  SYNONYM 
#       89      107
table(d_xx$rank)
# SPECIES 
#     196 


# Dive into duplicate species:
# 1. sp_key_am: SLB-61269; sp_id_gbif: 2261720; 
#   scientificName: Acanella eburnea (Pourtalès, 1868); 
#   status:SYNONYM
#   rank:SPECIES;
#   speciesKey:2261717
#   * https://www.gbif.org/species/2261720
#   
# 2. sp_key_am: SLB-61269; sp_id_gbif: 2261717;           # different
#   scientificName: Acanella arbuscula (Johnson, 1862)   # different 
#   status:ACCEPTED                                      # different
#   rank:SPECIES; speciesKey:2261717                     # same
#   * https://www.gbif.org/species/2261717
# TODO: Check that occurrences of A. eburnea contained in its accepted synonym A. arbuscula?
# TODO: Merge or pick AquaMaps SDM for accepted A. arbuscula over its synonym A. eburnea

(d_species_xxgt2 <- tbl(con, "spp") |> 
    group_by(species) |> 
    summarize(n = n()) |> 
    filter(n > 2))
#   species                    n
#   <chr>                <int64>
# 1 NA                        18
# 2 Lycaea bovallii            3
# 3 Laurencia dendroidea       3
species_xxgt2 <- d_species_xxgt2 |> pull(species)
d_spp_dupesgt2 <- tbl(con, "spp") |> 
  filter(
    is.na(species) |
      species %in% species_xxgt2) |> 
  collect() 
write_csv(d_spp_dupesgt2, "data/spp_duplicatesgt2.csv")
d_spp_dupesgt2 |> 
  select(status,	matchType) |> 
  table()
#           matchType
# status     EXACT HIGHERRANK
#   ACCEPTED     2         16
#   SYNONYM      6          0
d_spp_dupesgt2 |>
  mutate(
    acceptedUsageKey_isna = is.na(acceptedUsageKey)) |> 
  select(acceptedUsageKey_isna,	matchType) |> 
  table()
#                      matchType
# acceptedUsageKey_isna EXACT HIGHERRANK
#                 FALSE     6          0
#                 TRUE      2         16
d_spp_dupesgt2 |>
  mutate(
    acceptedUsageKey_isna = is.na(acceptedUsageKey),
    spidgbif_isusagekey   = sp_id_gbif == acceptedUsageKey) |> 
  select(acceptedUsageKey_isna,	spidgbif_isusagekey) |> 
  table(useNA = "ifany")
#                      spidgbif_isusagekey
# acceptedUsageKey_isna FALSE <NA>
#                 FALSE     6    0
#                 TRUE      0   18

d_spp_dupesgt2_ok <- d_spp_dupesgt2 |> 
  filter(
    status    == "ACCEPTED",
    matchType == "EXACT")
View(d_spp_dupesgt2_ok)


d_spp_rlna <- tbl(con, "spp") |> 
  filter(
    is.na(iucnRedListCategory)) |>  # |
      # iucnRedListCategory %in% c("DD","NE")) |> 
  distinct(sp_id_gbif, species) |>  # TODO: remove/sort duplicates
  arrange(species) |> 
  collect()
sum(duplicated(d_spp_rlna$species))
# nrow(d_spp_rlna) # 8,538 # 3,267

spp <- tbl(con, "spp") |> 
  filter(!is.na(species)) |> 
  distinct(species) |> 
  arrange(species) |> 
  pull(species)

# redo
dbRemoveTable(con, "spp_iucn")
dbRemoveTable(con, "spp_iucn_assessments")
dbRemoveTable(con, "spp_iucn_assessment_details")

for (i in 1:length(spp)){  # i=309
  sp <- spp[i]
  
  message(glue("{format(Sys.time())} {i}/{length(spp)} {sp}"))
  # https://api.iucnredlist.org/api-docs/index.html
  # https://api.iucnredlist.org/api/v4/taxa/scientific_name?genus_name=Ablennes&species_name=hians
  
  req <- request("https://api.iucnredlist.org/api/v4/") |>
    req_headers(Authorization = tkn_v4) |>
    req_url_path_append("taxa/scientific_name") |>
    req_url_query(
      genus_name   = strsplit(sp, " ", fixed = T)[[1]][1],
      species_name = strsplit(sp, " ", fixed = T)[[1]][2]) |> 
    req_error(is_error = \(resp) FALSE)
  resp <- req_perform(req)

  while(resp_status(resp) == 429){
    message("\tretry")
    Sys.sleep(10)
    resp <- req_perform(req)
  }
  if (resp_status(resp) == 404){
    message("\tnot found")
    next
  }
  
  o <- resp |>
    resp_body_json()

  # extract taxonomic info, especially IUCN species identifier sis_id -> sp_id_iucn 
  message("\td_sp")
  d_sp <- o$taxon[
    !names(o$taxon) %in% 
      c("species_taxa", "infrarank_taxa","subpopulation_taxa",
        "ssc_groups", "common_names","synonyms")] |> 
    bind_rows() |> 
    rename(sp_id_iucn = sis_id) |> 
    mutate(
      across(where(is.logical), as.character),
      json = as.character(toJSON(o)))
  # inject into db table
  dbWriteTable(con, "spp_iucn", d_sp, append = T, row.names = F)
  
  # TODO: inject into table spp_iucn
  
  if (length(o$assessments) == 0)
    next
  message("\td_as")
  d_as <- o$assessments %>%
    map_dfr(~{
      # Extract the base level information
      base_info <- list(
        sp_id_iucn                   = .x$sis_taxon_id,
        assessment_id                = .x$assessment_id,
        year_published               = .x$year_published,
        latest                       = .x$latest,
        possibly_extinct             = .x$possibly_extinct,
        possibly_extinct_in_the_wild = .x$possibly_extinct_in_the_wild,
        url                          = .x$url)
      
      # Extract scope information (taking first scope if multiple exist)
      scope_info <- list(
        scope_description = .x$scopes[[1]]$description$en,
        scope_code        = .x$scopes[[1]]$code,
        json              = as.character(toJSON(o)))
      
      # Combine and convert to tibble
      c(base_info, scope_info) %>%
        as_tibble()
    })
  # inject into db table
  dbWriteTable(con, "spp_iucn_assessments", d_as, append = T, row.names = F)
  
  as_id <- d_as |> 
    filter(scope_description == "Global") |> 
    pull(assessment_id)
  if (length(as_id) == 1){
    message("\td_asg")
    # https://api.iucnredlist.org/api/v4/assessment/15603320
    
    req <- request("https://api.iucnredlist.org/api/v4/") |>
      req_headers(Authorization = tkn_v4) |>
      req_url_path_append("assessment",as_id) |> 
      req_error(is_error = \(resp) FALSE)
    resp <- req_perform(req)
    
    while(resp_status(resp) == 429){
      message("\t\tretry")
      Sys.sleep(10)
      resp <- req_perform(req)
    }
    
    o <- resp |>
      resp_body_json()
    
    if ("error" %in% names(o)){
      message("\t\t", o$error)
      next
    }
    
    d_asg <- with(
      o,
      tibble(
        sp_id_iucn             = sis_taxon_id,
        assessment_id          = assessment_id,
        year_published         = year_published,
        red_list_category_code = red_list_category$code,
        population_trend       = population_trend$code,
        assessment_points      = assessment_points,
        assessment_ranges      = assessment_ranges,
        json                   = as.character(toJSON(o)) ))
    
    # inject into db table
    dbWriteTable(con, "spp_iucn_assessment_details", d_asg, append = T, row.names = F)
  }
}
```


```{r redlist ck}
t_spp_iucn <- tbl(con, "spp_iucn") |> 
  collect()
length(spp)       # 10,459
nrow(t_spp_iucn)  #  3,442

stopifnot(nrow(filter(t_spp_iucn, !scientific_name %in% spp)) == 0)

d_spp <- tbl(con, "spp") |> 
  select(sp_key_am, sp_id_gbif, acceptedUsageKey, scientificName, canonicalName, verbatim_name, rank, status, matchType, iucnRedListCategory) |> 
  collect()

stopifnot(sum(duplicated(d_spp$sp_key_am))==0)
table(d_spp$iucnRedListCategory, useNA = "ifany")
# CR   DD   EN   EX   LC   NE   NT   VU <NA> 
# 25  114   41    1 1827 5157   52   92 3267

tbl(con, "spp_iucn") |> 
  collect()

d_spp_iucn <- tbl(con, "spp_iucn") |> 
      select(scientific_name, sp_id_iucn, authority) |> 
      left_join(
        tbl(con, "spp_iucn_assessment_details") |> 
          select(sp_id_iucn, assessment_id, year_published, red_list_category_code),
        by = "sp_id_iucn") |> 
  collect()
table(d_spp_iucn$red_list_category_code, useNA = "ifany")
# CR   DD   EN   LC   NT   VU <NA> 
#  7  135   12 1931   29   21 1307
```


- [rgbif gbif_credentials](https://docs.ropensci.org/rgbif/articles/gbif_credentials.html)\
  `/Users/bbest/My Drive/private/gbif.org_ecoquants.txt`

```{r}
#| eval: false

usethis::edit_r_environ()
```


```{r cleanup, include=FALSE}
# Disconnect from the database
DBI::dbDisconnect(con)
```
