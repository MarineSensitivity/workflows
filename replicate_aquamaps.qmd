---
title: "Replicate AquaMaps"
description: "Compare replicated AquaMaps species distributions against the original"
execute:
  warning: false
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup

librarian::shelf(
  cmocean, DBI, dplyr, DT, duckdb, fs, glue, here, htmltools, janitor, knitr,
  leaflet, leaflet.extras, leaflet.extras2, librarian, logger, mapview, ggplot2, 
  listviewer, purrr, scales, marinesensitivity/msens, RColorBrewer, readr, sf, stringr, 
  terra, tibble, tidyr,
  quiet = T)
options(readr.show_col_types = F)
mapviewOptions(basemaps = "Esri.OceanBasemap")

path_dd   <- ifelse(
  Sys.info()["sysname"] == "Linux",
  "/share/data/aquamapsduckdb/am.duckdb",
  glue("~/My Drive/projects/msens/data/derived/aquamaps/am.duckdb"))
dir_cache <- here("data/replicate_aquamaps")
dir.create(dir_cache, showWarnings = FALSE, recursive = TRUE)

con_dd    <- dbConnect(
  duckdb(
    dbdir     = path_dd,
    read_only = T))

# Load functions from libs/am_functions.R
source(here("libs/am_functions.R"))
```

## Test Functions with a Single Species

```{r}
#| label: test_single_species

# source(here("libs/am_functions.R"))

# Test with a single species
# sp_key <- "W-Msc-419703"  # Crepidula depressa
# sp_key <- "ITS-Mam-180530"
# sp_key <- "Fis-22747" # Cetorhinus maximus bbox inside issue
# sp_key <- "ITS-Mam-180527" # fin whale sorted
# sp_key <- "ITS-Mam-180524" # sorted with tolerance 0.01
# sp_key <- "W-Pol-129784"
sp_key <- "Fis-22747"

# Get species information with enhanced details
sp_info <- get_sp_info(sp_key, con_dd)
jsonedit(sp_info)

# Get original raster
r_sp_old <- get_species_raster(sp_key, con_dd, dir_cache = dir_cache)

# Replicate raster using enhanced species info
r_sp_new <- replicate_sp_raster(sp_key, con_dd, dir_cache = dir_cache, redo = T)

ext(r_sp_old)
ext(r_sp_new)

# Compare rasters
matches <- compare_rasters(r_sp_old, r_sp_new)
cat(glue("Rasters match: {matches}\n"))

if (!matches) {
  # Get difference raster
  r_dif <- compare_rasters(r_sp_old, r_sp_new, return = "rast")
  plet(r_dif)
  
  # Get detailed comparison data
  d_cmp <- compare_rasters(r_sp_old, r_sp_new, return = "tibble", sp_key = sp_key, con_dd = con_dd)
  
  # # Examine specific cell differences
  # x <- d_cmp |>
  #   filter(dif_abs > 0.02) |>
  #   slice(1:10)
  # View(x)
}

# Visual comparison
compare_sp(r_sp_old, r_sp_new, sp_key)

# Interactive diagnostic visualization
create_diagnostic_visual(sp_key, con_dd)
```

## Create Diagnostic Table

```{r}
#| label: create_diagnostic_table

# Select a small sample of species for testing
sample_sp_keys <- c(
  "Fis-22747",   # Cetorhinus maximus (bbox hole issue)
  "ITS-Mam-180527", # Fin whale
  "W-Pol-129784",
  "ITS-Mam-180524",
  "W-Msc-419703")  # Crepidula depressa

# source(here("libs/am_functions.R"))
# Create diagnostic table
diag_table <- create_diagnostic_table(sample_sp_keys, con_dd)

# Display the diagnostic table
diag_table |>
  DT::datatable(
    caption = "AquaMaps Species Diagnostic Comparison",
    options = list(scrollX = TRUE))

# Save diagnostic table
write_csv(diag_table, here("data/aquamaps_diagnostic_table.csv"))
```

## Validate Multiple Species

```{r}
#| label: validate_multiple_species

ply_br_a_geo     <- glue("{dir_cache}/ply_boemrgns_antimeridian.geojson")
ply_cells_br_geo <- glue("{dir_cache}/ply_cells_boemrgns.geojson")
spp_br_csv       <- glue("{dir_cache}/spp_boemrgns.csv")
do_map_br        <- F

# get regions, breaking on antimeridan
if (!file.exists(ply_br_a_geo)) {
  sf_use_s2(F)
  ply_br_a <- msens::ply_boemrgns |> 
    st_break_antimeridian()
  sf_use_s2(T)
  
  write_sf(
    ply_br_a, 
    ply_br_a_geo, 
    delete_dsn = T)
}
ply_br_a <- read_sf(ply_br_a_geo)

# get cells in regions
if (!file.exists(ply_cells_br_geo)) {
  # get cells in regions
  pts_cells <- tbl(con_dd, "cells") |> 
  select(cell_id, center_long, center_lat) |> 
  collect() |> 
  st_as_sf(
    coords = c("center_long", "center_lat"), crs = 4326)

  # create template raster from global dimensions and resolution
  r_g <- rast(
    xmin = -180, xmax = 180, 
    ymin = -90,  ymax = 90, 
    resolution = 0.5)
  
  # rasterize based on cell_id
  r_cells <- rasterize(pts_cells, r_g, field = "cell_id", fun = "last")
  names(r_cells) <- "cell_id"
  
  # convert to polygons
  ply_cells <- as.polygons(r_cells) |> 
    st_as_sf() |> 
    st_set_crs(4326) |> 
    st_cast("POLYGON")
  
  # identify boem regions per cell
  ply_cells_br <- ply_cells |> 
    st_filter(ply_br_a, .predicate = st_intersects)
  
  write_sf(
    ply_cells_br, 
    ply_cells_br_geo, 
    delete_dsn = T)
}
ply_cells_br <- read_sf(ply_cells_br_geo) |> 
  mutate(one = "one") |> 
  relocate(one)

if (do_map_br)
  mapView(ply_br_a, col.regions = "red", alpha = 0.5) +
    mapView(ply_cells_br, col.regions = "blue", alpha = 0.5)

if (!file.exists(spp_br_csv)) {
  # get species in boem regions with number of cells
  d_spp_br <- tbl(con_dd, "spp_cells") |> 
    filter(cell_id %in% ply_cells_br$cell_id) |>
    group_by(sp_key) |>
    summarize(n_cells_br = n()) |> 
    collect() |> 
    arrange(sp_key)

  write_csv(
    d_spp_br, 
    spp_br_csv)
}
d_sp_br  <- read_csv(spp_br_csv)

# Option to limit number of species for testing
max_species <- 50  # Set to NULL for all species
if (!is.null(max_species)) {
  set.seed(123)  # For reproducibility
  all_sp_keys <- d_sp_br |> 
    filter(n_cells_br > 1) |> 
    arrange(desc(n_cells_br), sp_key) |>
    pull(sp_key)
  sample_sp_keys <- sample(all_sp_keys, min(max_species, length(all_sp_keys)))
} else {
  sample_sp_keys <- d_sp_br |> 
    filter(n_cells_br > 1) |> 
    arrange(desc(n_cells_br), sp_key) |>
    pull(sp_key)
}

# Validate species
results <- validate_aquamaps_species(sample_sp_keys, con_dd, dir_cache = dir_cache, verbosity = 1)

# Save results to CSV
results_csv <- here("data/aquamaps_validation_results.csv")
write_csv(results, results_csv)

# Display summary
cat(glue("Total species processed: {nrow(results)}\n"))
cat(glue("Species with matching rasters: {sum(results$r_matches, na.rm=TRUE)}\n"))
cat(glue("Species with non-matching rasters: {sum(!results$r_matches, na.rm=TRUE)}\n"))
cat(glue("Species with errors: {sum(is.na(results$r_matches))}\n"))

# Show results table
results |>
  DT::datatable(
    caption = "AquaMaps Validation Results",
    options = list(pageLength = 25))
```

## Create Full Diagnostic Table

```{r}
#| label: create_full_diagnostic
#| eval: false

# Create a full diagnostic table for non-matching species
# This can be time-consuming, so we'll focus on just the non-matching species
nonmatching_sp_keys <- results |> 
  filter(!r_matches) |> 
  pull(sp_key)

# If there are too many, sample a subset
if (length(nonmatching_sp_keys) > 20) {
  set.seed(456)
  nonmatching_sp_keys <- sample(nonmatching_sp_keys, 20)
}

# Create diagnostic table for non-matching species
full_diag_table <- create_diagnostic_table(nonmatching_sp_keys, con_dd)

# Save to CSV
write_csv(full_diag_table, here("data/aquamaps_full_diagnostic.csv"))

# Display
full_diag_table |>
  DT::datatable(
    caption = "Full Diagnostic for Non-matching Species",
    options = list(scrollX = TRUE))

# Analyze patterns
full_diag_table |>
  group_by(is_bbox_hole, sp_class, is_surface) |>
  summarize(count = n(), .groups = "drop") |>
  arrange(desc(count)) |>
  DT::datatable(caption = "Patterns in Non-matching Species")
```

## Analyze Results

```{r}
#| label: analyze_results

# Load results if previously saved
if (file.exists(here("data/aquamaps_validation_results.csv"))) {
  results <- read_csv(here("data/aquamaps_validation_results.csv"))
}

# Get details about species that don't match
if (sum(!results$r_matches, na.rm=TRUE) > 0) {
  non_matching_sp <- results |>
    filter(!r_matches) |>
    pull(sp_key)
  
  # Get species information
  non_matching_info <- tbl(con_dd, "spp") |>
      filter(sp_key %in% non_matching_sp) |>
      collect() |>
      left_join(
        tbl(con_dd, "spp_prefs") |>
          filter(sp_key %in% non_matching_sp) |>
          select(sp_key, pelagic, map_opt, layer) |>
          collect(),
        by = "sp_key")
  
  # Analyze patterns in non-matching species
  non_matching_info |>
    group_by(class) |>
    summarize(count = n(), .groups = "drop") |>
    arrange(desc(count)) |>
    DT::datatable(caption = "Non-matching species by class")
  
  non_matching_info |>
    group_by(pelagic) |>
    summarize(count = n(), .groups = "drop") |>
    DT::datatable(caption = "Non-matching species by pelagic status")
  
  non_matching_info |>
    group_by(map_opt) |>
    summarize(count = n(), .groups = "drop") |>
    DT::datatable(caption = "Non-matching species by map option")
  
  non_matching_info |>
    group_by(layer) |>
    summarize(count = n(), .groups = "drop") |>
    DT::datatable(caption = "Non-matching species by layer (s=surface, b=bottom)")
  
  # Examine a sample of non-matching species in detail
  sample_sp <- sample(non_matching_sp, min(5, length(non_matching_sp)))
  
  for (sp in sample_sp) {
    # Get original and replicated rasters
    r_old <- get_species_raster(sp, con_dd, dir_cache = dir_cache)
    r_new <- replicate_sp_raster(sp, con_dd, dir_cache = dir_cache)
    
    # Create comparison map
    cat(glue("\nExample non-matching species: {sp}\n"))
    compare_sp(r_old, r_new, sp)
    
    # Create diagnostic visualization
    create_diagnostic_visual(sp, con_dd)
  }
}
```

## Get Bio-Oracle v3 higher resolution data

-   [Bio-ORACLE : Marine data layers for ecological modelling](https://www.bio-oracle.org/documentation.php)
-   [Bio-ORACLE : Marine data layers for ecological modelling](https://www.bio-oracle.org/downloads-to-email.php)
-   [bio-oracle/biooracler: R package to access Bio-Oracle data via ERDDAP](https://github.com/bio-oracle/biooracler)
-   [ERDDAP - List of All Datasets](https://erddap.bio-oracle.org/erddap/info/index.html?page=1&itemsPerPage=1000)
-   [Copernicus Marine Data Store \| Copernicus Marine Service](https://data.marine.copernicus.eu/products)

```{r}
#| label: bio-oracle
#| eval: false

librarian::shelf(
  bio-oracle/biooracler,
  quiet = T)

# biooracler:::erddap.bio_oracle.org()
# http://erddap.bio-oracle.org/erddap/
bo_lyrs_csv <- here("data/bio-oracle_layers.csv")

biooracler::list_layers() |> 
  write_csv(bo_lyrs_scsv)

bo_lyrs <- read_csv(bo_lyrs_csv)
  DT::datatable()
```

## Match AquaMaps env to Bio-Oracle layers

```{r}
#| label: match_aquamaps_bio-oracle
#| eval: false

librarian::shelf(
  dplyr, 
  quiet = T)

d_sp_pref |> 
  select(ends_with("_yn")) |> 
  names() |> 
  str_replace("_yn", "")

# "depth"     "temp"      "salinity"  "prim_prod" "ice_con"   "oxy"       "land_dist" "extn_rule"
```

-   `depth`: terrain_characteristics.bathymetry_min\|mean\|max


## Conclusion

This document validates the replication process for AquaMaps species distribution models. It compares the original AquaMaps rasters with our replicated versions to ensure our environmental envelope approach correctly reproduces the original rasters.

The key enhancements from the previous version include:

1. Modular function organization in `libs/am_functions.R`
2. Enhanced species information with actual bounding box and FAO areas
3. Detection of bounding box "holes" where east < west longitude
4. Comprehensive diagnostic table for comparing species properties
5. Interactive diagnostic visualization for examining discrepancies
6. Streamlined performance through caching and optimized functions

The validation report helps identify any discrepancies between the original and replicated models, which can inform further refinements to the replication approach.
